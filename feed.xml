<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2019-04-22T10:43:56+08:00</updated><id>/feed.xml</id><title type="html">一叶障目</title><subtitle>学无止境</subtitle><entry><title type="html">Go学习笔记2</title><link href="/go/2019/04/17/Go-2.html" rel="alternate" type="text/html" title="Go学习笔记2" /><published>2019-04-17T00:00:00+08:00</published><updated>2019-04-17T00:00:00+08:00</updated><id>/go/2019/04/17/Go-2</id><content type="html" xml:base="/go/2019/04/17/Go-2.html">&lt;p&gt;Go数据类型有如下类型。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;基础类型&lt;/li&gt;
  &lt;li&gt;符合类型&lt;/li&gt;
  &lt;li&gt;引用类型&lt;/li&gt;
  &lt;li&gt;接口类型
类型内容很多只能慢慢学习，今天学习基础类型。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;基础类型&quot;&gt;基础类型&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;数字
    &lt;ul&gt;
      &lt;li&gt;有符号无符号&lt;/li&gt;
      &lt;li&gt;Unicode字符rune类型是和int32等价的类型&lt;/li&gt;
      &lt;li&gt;byte也是uint8类型的等价类型&lt;/li&gt;
      &lt;li&gt;计算溢出 高位截断
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; var u uint8 = 255
 fmt.Println(u, u+1, u*u) // &quot;255 0 1&quot;
 var i int8 = 127
 fmt.Println(i, i+1, i*i) // &quot;127 -128 1&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;位运算
  ```
 var x uint8 = 1«1 | 1«5var y uint8 = 1«1 | 1«2&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;fmt.Printf(“%08b\n”, x) // “00100010”, the set {1, 5}
 fmt.Printf(“%08b\n”, y) // “00000110”, the set {1, 2}&lt;/p&gt;

    &lt;p&gt;fmt.Printf(“%08b\n”, x&amp;amp;y)  // “00000010”, the intersection {1}
 fmt.Printf(“%08b\n”, x|y)  // “00100110”, the union {1, 2, 5}
 fmt.Printf(“%08b\n”, x^y)  // “00100100”, the symmetric difference {2, 5}
 fmt.Printf(“%08b\n”, x&amp;amp;^y) // “00100000”, the difference {5}&lt;/p&gt;

    &lt;p&gt;for i := uint(0); i &amp;lt; 8; i++ {
     if x&amp;amp;(1«i) != 0 { // membership test
         fmt.Println(i) // “1”, “5”
     }
 }&lt;/p&gt;

    &lt;p&gt;fmt.Printf(“%08b\n”, x«1) // “01000100”, the set {2, 6}
 fmt.Printf(“%08b\n”, x»1) // “00010001”, the set {0, 4}
  ```&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;浮点型
        &lt;blockquote&gt;
          &lt;p&gt;一个float32类型的浮点数可以提供大约6个十进制数的精度，而float64则可以提供约15个十进制数的精度；通常应该优先使用float64类型，因为float32类型的累计计算误差很容易扩散，并且float32能精确表示的正整数并不是很大（译注：因为float32的有效bit位只有23个，其它的bit位用于指数和符号；当整数大于23bit能表达的范围时，float32的表示将出现误差）&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;字符串:一个字符串是一个不可改变的字节序列
    &lt;ul&gt;
      &lt;li&gt;不变性意味如果两个字符串共享相同的底层数据的话也是安全的，这使得复制任何长度的字符串代价是低廉的&lt;/li&gt;
      &lt;li&gt;编码：编码是一个基础，但是很复杂的东西，很多原理都跟编码有关。
        &lt;ul&gt;
          &lt;li&gt;ASC II：是最初的编码定义，用一个字节来表示 0-127 表示英文和符号&lt;/li&gt;
          &lt;li&gt;Unicode：随着计算机的广泛使用，其他国家的语言和文字需要展示，一个字节不够用了所以用4个字节来保存，诞生了unicode编码，至今unicode已经120000的字符了&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;http://unicode.org &quot;&gt;Unicode官方&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;UTF-8:由于unicode 需要4个字节，有字符实际用不到这么多存储为，但是占用了这么的空间很浪费，所以UTF-8可变长字编码格式产生了，它位不同的长度的Uicode编码使用不用的表示方式。如下
            &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 0xxxxxxx                                                   runes 0-127    (ASCII)
 110xxxxx 10xxxxxx                                  128-2047       (values &amp;lt;128 unused)
 1110xxxx 10xxxxxx 10xxxxxx                   2048-65535     (values &amp;lt;2048 unused)
 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx   65536-0x10ffff (other values unused)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;Go语言的range循环在处理字符串的时候，会自动隐式解码UTF8字符串&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;标准库中四个重要的库
        &lt;ul&gt;
          &lt;li&gt;btyes:btye的查找，替换，比较，截取，拆分，合并等功能
            &lt;ul&gt;
              &lt;li&gt;因为字符串是只读的，因此逐步构建字符串会导致很多分配和复制&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;strings：字符串btye的查找，替换，比较，截取，拆分，合并等功能&lt;/li&gt;
          &lt;li&gt;strconv：字符串转化&lt;/li&gt;
          &lt;li&gt;unicode：给字符分类&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;布尔：没有什么特别注意的，就是要讲数字当bool值需要做一个函数转换
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; func itob(i int) bool { return i != 0 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;常量：常量表达式的值在编译期计算，而不是在运行期。
    &lt;ul&gt;
      &lt;li&gt;iota 可以批量生成常量
 ```angular2html
 type Weekday int&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;const (
     Sunday Weekday = iota
     Monday
     Tuesday
     Wednesday
     Thursday
     Friday
     Saturday
 )
 //复杂例子
 const (
     _ = 1 « (10 * iota)
     KiB // 1024
     MiB // 1048576
     GiB // 1073741824
     TiB // 1099511627776             (exceeds 1 « 32)
     PiB // 1125899906842624
     EiB // 1152921504606846976
     ZiB // 1180591620717411303424    (exceeds 1 « 64)
     YiB // 1208925819614629174706176
 )
 ```&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;无类型常量：我个人理解无类型常量有点像php不定义变量类型，系统自动识别，后面学习到接口时有重要的作用。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;虽然每种语言都有这些类型，但是每种语言在细节处理上有相似也有不同，这些相似和不同就体现出了不同人的思考方式，总之代码是死的，思维是活的。多思考多实践，形成自己的思维体系更重要。&lt;/p&gt;</content><author><name></name></author><summary type="html">Go数据类型有如下类型。 基础类型 符合类型 引用类型 接口类型 类型内容很多只能慢慢学习，今天学习基础类型。</summary></entry><entry><title type="html">Go学习笔记2</title><link href="/go/2019/04/17/Go-3.html" rel="alternate" type="text/html" title="Go学习笔记2" /><published>2019-04-17T00:00:00+08:00</published><updated>2019-04-17T00:00:00+08:00</updated><id>/go/2019/04/17/Go-3</id><content type="html" xml:base="/go/2019/04/17/Go-3.html">&lt;p&gt;Go数据类型有如下类型。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;基础类型&lt;/li&gt;
  &lt;li&gt;复合类型&lt;/li&gt;
  &lt;li&gt;引用类型&lt;/li&gt;
  &lt;li&gt;接口类型
类型内容很多只能慢慢学习，今天学习复合类型。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;复合类型&quot;&gt;复合类型&lt;/h2&gt;
&lt;h3 id=&quot;符合类型分类&quot;&gt;符合类型分类&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;固定长度
    &lt;ul&gt;
      &lt;li&gt;数组&lt;/li&gt;
      &lt;li&gt;结构体&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;动态长度
    &lt;ul&gt;
      &lt;li&gt;slice&lt;/li&gt;
      &lt;li&gt;map
        &lt;h3 id=&quot;类型详解&quot;&gt;类型详解&lt;/h3&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;数组：数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成
    &lt;ul&gt;
      &lt;li&gt;我们将会发现，数组、slice、map和结构体字面值的写法都很相似。是直接提供顺序初始化值序列，但是也可以指定一个索引和对应值列表的方式初始化，就像下面这样：
  ```
  type Currency int&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;const (
      USD Currency = iota // 美元
      EUR                 // 欧元
      GBP                 // 英镑
      RMB                 // 人民币
  )&lt;/p&gt;

    &lt;p&gt;symbol := […]string{USD: “$”, EUR: “€”, GBP: “￡”, RMB: “￥”}&lt;/p&gt;

    &lt;p&gt;fmt.Println(RMB, symbol[RMB]) // “3 ￥”&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  * 数组是可以直接比较的
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;import “crypto/sha256”&lt;/p&gt;

    &lt;p&gt;func main() {
      c1 := sha256.Sum256([]byte(“x”))
      c2 := sha256.Sum256([]byte(“X”))
      fmt.Printf(“%x\n%x\n%t\n%T\n”, c1, c2, c1 == c2, c1)
      // Output:                  &lt;br /&gt;
      //2d711642b726b04401627ca9fbac32f5c8530fb1903cc4db02258717921a4881
      // 4b68ab3847feda7d6c62c1fbcbeebfa35eab7351ed5e78f4ddadea5df64b8015
      // false
      // [32]uint8
  }
  ```&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;Go语言对待数组的方式和其它很多编程语言不同，其它编程语言可能会隐式地将数组作为引用或指针对象传入被调用的函数。
        &lt;blockquote&gt;
          &lt;p&gt;因为函数对待参数是值传递，需要复制参数变量，有些变成语言回见数据组隐式的转换为引用，以减少复制大型参数造成的额外开销。&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;虽然通过指针来传递数组参数是高效的，而且也允许在函数内部修改数组的值，但是数组依然是僵化的类型，因为数组的类型包含了僵化的长度信息。由于这些原因，除了像SHA256这类需要处理特定大小数组的特例外，数组依然很少用作函数参数；相反，我们一般使用slice来替代数组。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;slice：底层是用数组实现的，支持动态的扩容
    &lt;ul&gt;
      &lt;li&gt;组成
        &lt;ul&gt;
          &lt;li&gt;指针：指针指向第一个slice元素对应的底层数组元素的地址，要注意的是slice的第一个元素并不一定就是数组的第一个元素&lt;/li&gt;
          &lt;li&gt;长度：长度对应slice中元素的数目，长度不能超过容量&lt;/li&gt;
          &lt;li&gt;容量：容量一般是从slice的开始位置到底层数据的结尾位置。内置的len和cap函数分别返回slice的长度和容量。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;多个slice之间可以共享底层的数据，并且引用的数组部分区间可能重叠。图4.1显示了表示一年中每个月份名字的字符串数组，还有重叠引用了该数组的两个slice。
 &lt;img src=&quot;/images/10.png&quot; alt=&quot;9ca9eaf81a29acc6f76294e5cf97a179.png&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;因为slice值包含指向第一个slice元素的指针，因此向函数传递slice将允许在函数内部修改底层数组的元素。换句话说，复制一个slice只是对底层的数组创建了一个新的slice别名。下面的reverse函数在原内存空间将[]int类型的slice反转，而且它可以用于任意长度的slice。
 ```
 func reverse(s []int) {
  for i, j := 0, len(s)-1; i &amp;lt; j; i, j = i+1, j-1 {
      s[i], s[j] = s[j], s[i]
  }
 }&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;a := […]int{0, 1, 2, 3, 4, 5}
 reverse(a[:])
 fmt.Println(a) // “[5 4 3 2 1 0]”
 ```&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;slice底层是数组但并不能像数组一样比较。
        &lt;ul&gt;
          &lt;li&gt;一个原因slice的元素是间接引用的，一个slice甚至可以包含自身&lt;/li&gt;
          &lt;li&gt;第二个原因，因为slice的元素是间接引用的，一个固定的slice值(译注：指slice本身的值，不是元素的值)在不同的时刻可能包含不同的元素，因为底层数组的元素可能会被修改。slice扩容是地址也会发生改变。鉴于安全考虑直接禁止slice之间的比较操作，简化复杂度。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;判断空slice
        &lt;ul&gt;
          &lt;li&gt;如果你需要测试一个slice是否是空的，使用len(s) == 0来判断，而不应该用s == nil来判断。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;结构体：相当于类
    &lt;ul&gt;
      &lt;li&gt;一个命名为S的结构体类型将不能再包含S类型的成员：因为一个聚合的值不能包含它自身。（该限制同样适应于数组。）但是S类型的结构体可以包含*S指针类型的成员，这可以让我们创建递归的数据结构，比如链表和树结构等。&lt;/li&gt;
      &lt;li&gt;Go语言有一个特性让我们只声明一个成员对应的数据类型而不指名成员的名字；这类成员就叫匿名成员。匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针。下面的代码中，Circle和Wheel各自都有一个匿名成员。我们可以说Point类型被嵌入到了Circle结构体，同时Circle类型被嵌入到了Wheel结构体。
  ```
  type Point struct {
  X, Y int
  }&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;type Circle struct {
      Center Point
      Radius int
  }&lt;/p&gt;

    &lt;p&gt;type Wheel struct {
      Circle Circle
      Spokes int
  }&lt;/p&gt;

    &lt;p&gt;var w Wheel
  w.X = 8            // equivalent to w.Circle.Point.X = 8
  w.Y = 8            // equivalent to w.Circle.Point.Y = 8
  w.Radius = 5       // equivalent to w.Circle.Radius = 5
  w.Spokes = 20
  ```&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;在右边的注释中给出的显式形式访问这些叶子成员的语法依然有效，因此匿名成员并不是真的无法访问了。其中匿名成员Circle和Point都有自己的名字——就是命名的类型名字——但是这些名字在点操作符中是可选的。我们在访问子成员的时候可以忽略任何匿名成员部分。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;map
    &lt;ul&gt;
      &lt;li&gt;map 底层也是固定数组，通过哈希表映射&lt;/li&gt;
      &lt;li&gt;map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作，禁止对map元素取址的原因是map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效。&lt;/li&gt;
      &lt;li&gt;Map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。这是故意的，每次都使用随机的遍历顺序可以强制要求程序不会依赖具体的哈希函数实现。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;类型就是数据结构，写代码先定义数据结构，数据结构决定了代码的走向决定了用什么算法。学海无涯苦作舟，千帆过尽还复来。继续努力吧。&lt;/p&gt;</content><author><name></name></author><summary type="html">Go数据类型有如下类型。 基础类型 复合类型 引用类型 接口类型 类型内容很多只能慢慢学习，今天学习复合类型。</summary></entry><entry><title type="html">Go直播实践</title><link href="/go/live/2019/04/16/Go_live-1.html" rel="alternate" type="text/html" title="Go直播实践" /><published>2019-04-16T00:00:00+08:00</published><updated>2019-04-16T00:00:00+08:00</updated><id>/go/live/2019/04/16/Go_live-1</id><content type="html" xml:base="/go/live/2019/04/16/Go_live-1.html">&lt;p&gt;视频直播是近些年特别火的技术栈，一直想学习如何实现视频直播。初期也了解了一些协议相关的知识，苦于都是c++相关学习起来比较难以理解，学习了Go语言之后突然想找一找是否有Go语言实现的直播服务，惊奇的发现，Livego这个开源直播服务端，自此展开了Go直播实践之路，由于工作繁重，只能抽时间搞，耽误了好几天的更新，话不多说直入正题。&lt;/p&gt;

&lt;h2 id=&quot;服务端&quot;&gt;服务端&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/gwuhaolin/livego&quot;&gt;livego&lt;/a&gt; 精挑细选 简单可靠 便于二次开发&lt;/li&gt;
  &lt;li&gt;livego的相关参数可以看源码或者help非常直观&lt;/li&gt;
  &lt;li&gt;对于服务端不是很难编译到运行不到2分钟，主要是注意推流时，格式的选取&lt;/li&gt;
  &lt;li&gt;上行推流：使用ffmpeg上行视频流
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ffmpeg -re -i test.mp4 -c copy -f flv 
rtmp://192.168.112.20:1935/live/movie
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;总结：服务端是较为简单的没有任何难点&lt;/p&gt;
    &lt;h2 id=&quot;客户端&quot;&gt;客户端&lt;/h2&gt;
    &lt;p&gt;对于一个服务端来说，客户端编码是最让人头疼的。我选取的h5客户端流解析工具&lt;a href=&quot;https://github.com/bilibili/flv.js&quot;&gt;flv.js&lt;/a&gt;&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;p&gt;题外话
对于前端工具真的很烦，npm安装可把我搞惨了，我是虚拟机+共享目录，我在虚拟机中npm install 它居然不认识我的共享目录，总是在rename的时候，提示权限有误无法操作，致使我在构建flv.js客户端环境上花了大量的时间，把一个两天搞定的事，一周才搞定。我是通过在虚拟机其他目录进行install在将安装好的文件拷贝到共享目录，最终还是搞定了。还有吐槽一下哔哩哔哩这么一个厉害的前端同学才给5000的工资真的说不过去。给做开源的各位大大点赞。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;安装环境
    &lt;ul&gt;
      &lt;li&gt;克隆github&lt;/li&gt;
      &lt;li&gt;npm install&lt;/li&gt;
      &lt;li&gt;npm install -g gulp&lt;/li&gt;
      &lt;li&gt;gulp release
不知道这些组件是干什么用的，就按就得了哈哈
        &lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;nginx 配置demo&lt;/li&gt;
  &lt;li&gt;编译开启服务
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  go build
  ./livego
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;推流
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ffmpeg -re -i test.mp4 -c copy -f flv rtmp://192.168.112.20:1935/live/movie
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;demo中配置源&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/9.png&quot; alt=&quot;628bf39eeb1d51e6e0106e4bd5b6d08a.png&quot; /&gt;
 ## 总结&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;GO真的是一个好语言，一个好的粘合剂&lt;/li&gt;
  &lt;li&gt;前端工具真麻烦，像php的composer多好，还是前端的变化太快，跟不上潮流，还是喜欢一些底层一点的不那么麻烦。&lt;/li&gt;
  &lt;li&gt;直播
    &lt;ul&gt;
      &lt;li&gt;协议的实现&lt;/li&gt;
      &lt;li&gt;流的上行&lt;/li&gt;
      &lt;li&gt;流的下行&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;还有一些其他的可以学习的内容比如
    &lt;ul&gt;
      &lt;li&gt;视频的格式&lt;/li&gt;
      &lt;li&gt;流的缓存&lt;/li&gt;
      &lt;li&gt;压力测试&lt;/li&gt;
      &lt;li&gt;负载均衡&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;等等视频直播是一个大的技术栈不是像我这种简单的玩一下的，如果想深入做还是需要一定的功力和精力。只是供大家学习和体验。&lt;/p&gt;</content><author><name></name></author><summary type="html">视频直播是近些年特别火的技术栈，一直想学习如何实现视频直播。初期也了解了一些协议相关的知识，苦于都是c++相关学习起来比较难以理解，学习了Go语言之后突然想找一找是否有Go语言实现的直播服务，惊奇的发现，Livego这个开源直播服务端，自此展开了Go直播实践之路，由于工作繁重，只能抽时间搞，耽误了好几天的更新，话不多说直入正题。</summary></entry><entry><title type="html">Go学习笔记1</title><link href="/go/2019/04/11/Go-1.html" rel="alternate" type="text/html" title="Go学习笔记1" /><published>2019-04-11T00:00:00+08:00</published><updated>2019-04-11T00:00:00+08:00</updated><id>/go/2019/04/11/Go-1</id><content type="html" xml:base="/go/2019/04/11/Go-1.html">&lt;p&gt;最近写了很多了Go代码，但是对于Go的深入内容知之甚少，为了达到知其然，并知其所以然的想法。开始了学习之旅，首选学习素材&lt;a href=&quot;https://books.studygolang.com/gopl-zh/index.html&quot;&gt;GO圣经&lt;/a&gt;。把自己觉得有用的都记下来，以便以后拿来温习。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Go 没有的特性
    &lt;ul&gt;
      &lt;li&gt;它没有隐式的数值转换&lt;/li&gt;
      &lt;li&gt;没有构造函数和析构函数&lt;/li&gt;
      &lt;li&gt;没有运算符重载&lt;/li&gt;
      &lt;li&gt;没有默认参数&lt;/li&gt;
      &lt;li&gt;没有继承&lt;/li&gt;
      &lt;li&gt;没有泛型&lt;/li&gt;
      &lt;li&gt;没有异常&lt;/li&gt;
      &lt;li&gt;没有宏&lt;/li&gt;
      &lt;li&gt;没有函数修饰&lt;/li&gt;
      &lt;li&gt;更没有线程局部存储&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;声明的类型
    &lt;ul&gt;
      &lt;li&gt;var：变量&lt;/li&gt;
      &lt;li&gt;type：类型&lt;/li&gt;
      &lt;li&gt;const：常量&lt;/li&gt;
      &lt;li&gt;func：函数&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;各种类型对应的零值
    &lt;ul&gt;
      &lt;li&gt;数值对应的零值是0&lt;/li&gt;
      &lt;li&gt;布尔值对应零值是false&lt;/li&gt;
      &lt;li&gt;字符串对应零值是空字符串&lt;/li&gt;
      &lt;li&gt;接口或引用类型（包括slice、指针、map、chan和函数）对应nil&lt;/li&gt;
      &lt;li&gt;数组或者结构体对应内部每种类型对应的零值&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;变量的声明周期
    &lt;ul&gt;
      &lt;li&gt;变量的生命周期指的是在程序运行期间变量有效存在的时间间隔。对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，局部变量的声明周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。&lt;/li&gt;
      &lt;li&gt;垃圾回收
        &lt;ul&gt;
          &lt;li&gt;基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var global *int
func f() {
    var x int
    x = 1
    global = &amp;amp;x
}
func g() {
    y := new(int)
    *y = 1
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;f函数里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然它是在函数内部定义的；用Go语言的术语说，这个x局部变量从函数f中逃逸了。相反，当g函数返回时，变量&lt;em&gt;y将是不可达的，也就是说可以马上被回收的。因此，&lt;/em&gt;y并没有从函数g中逃逸，编译器可以选择在栈上分配*y的存储空间（也可以选择在堆上分配，然后由Go语言的GC回收这个变量的内存空间），虽然这里用的是new方式。其实在任何时候，你并不需为了编写正确的代码而要考虑变量的逃逸行为，要记住的是，逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;赋值
    &lt;ul&gt;
      &lt;li&gt;赋值语句是显式的赋值形式，但是程序中还有很多地方会发生隐式的赋值行为：函数调用会隐式地将调用参数的值赋值给函数的参数变量，一个返回语句会隐式地将返回操作的值赋值给结果变量，一个复合类型的字面量也会产生赋值行为。例如下面的语句：
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;medals := []string{&quot;gold&quot;, &quot;silver&quot;, &quot;bronze&quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;作用域
    &lt;ul&gt;
      &lt;li&gt;不要将作用域和生命周期混为一谈。声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时的属性。一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个运行时的概念。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;作用域类型
    &lt;ul&gt;
      &lt;li&gt;词法块：花括弧所包含的一系列语句&lt;/li&gt;
      &lt;li&gt;词法块可以深度嵌套，变量的生命周期在此法块中。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">最近写了很多了Go代码，但是对于Go的深入内容知之甚少，为了达到知其然，并知其所以然的想法。开始了学习之旅，首选学习素材GO圣经。把自己觉得有用的都记下来，以便以后拿来温习。</summary></entry><entry><title type="html">如何搭建本地docker registry</title><link href="/docker/2019/04/03/docker-local-registry.html" rel="alternate" type="text/html" title="如何搭建本地docker registry" /><published>2019-04-03T00:00:00+08:00</published><updated>2019-04-03T00:00:00+08:00</updated><id>/docker/2019/04/03/docker-local-registry</id><content type="html" xml:base="/docker/2019/04/03/docker-local-registry.html">&lt;p&gt;学习k8s制作镜像就是毕竟之路，而如果想要一个快速的仓库，本地仓库就是首选，所以学习单间本地dock registry很重要。&lt;/p&gt;

&lt;h2 id=&quot;获取镜像&quot;&gt;获取镜像&lt;/h2&gt;

&lt;p&gt;拉取远程镜像用于制作本地镜像&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-angular2html&quot;&gt;docker pull nginx:alpine
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;本地docker-registry&quot;&gt;本地docker registry&lt;/h2&gt;
&lt;p&gt;拉取docker registry&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-angular2html&quot;&gt;docker pull registry:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行docker registry&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-angular2html&quot;&gt;docker run \
  --detach \
  --name registry \
  --hostname registry \
  --volume $(pwd)/registry:/var/lib/registry/docker/registry \
  --publish 5000:5000 \
  --restart unless-stopped \
  registry:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;制作镜像&quot;&gt;制作镜像&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;利用DockerFile制作镜像&lt;/li&gt;
  &lt;li&gt;先将环境拉取到本地&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-angular2html&quot;&gt;//拉取官方php
docker pull php:7.1-cli-jessie
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;进入docker进行环境配置记录配置命令制作DockerFile&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-angular2html&quot;&gt;docker run -it php:7.1-cli-jessie /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/xiangdong1987/local-env/tree/master&quot;&gt;根据官方PHP镜像修改后的Dockerfile&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;容器相关命令&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-angular2html&quot;&gt;//容器属性
sudo docker inspect 6d4a2498c108 (容器id)
//容器ip
docker inspect [container_name] | grep IPAddress
//端口转发
iiptables -t nat -A DOCKER -p tcp -dport 8001 -j DNAT --to-destination 192.169.1.1:8080
//容器查看
sudo docker ps  /-a 
//删除容器
sudo docker rm 容器id
//容器镜像查看
sudo docker images 
//删除镜像
sudo docker image rm 镜像id
//运行docker -p 映射端口  -v 挂在目录  -it 进入容器
sudo docker run -p 8810:8810 -it chelun-test:v1 -v /data:/data /bin/bash

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;镜像的制作就是一个环境搭建的流程，需要细心的记录没一部操作，也要合理话层级。尽量用少的层级来实现环境的待见。后面的路还很长需要继续学习。&lt;/p&gt;</content><author><name></name></author><summary type="html">学习k8s制作镜像就是毕竟之路，而如果想要一个快速的仓库，本地仓库就是首选，所以学习单间本地dock registry很重要。</summary></entry><entry><title type="html">整体理解kubenets各种组件</title><link href="/kubernets/2019/04/03/kubernets-2.html" rel="alternate" type="text/html" title="整体理解kubenets各种组件" /><published>2019-04-03T00:00:00+08:00</published><updated>2019-04-03T00:00:00+08:00</updated><id>/kubernets/2019/04/03/kubernets-2</id><content type="html" xml:base="/kubernets/2019/04/03/kubernets-2.html">&lt;p&gt;在学习编排之前，认识kubernets的各种组件是很重要的。他们之间的关系是怎么样的？如果构建一个合理的服务？都是要在开始之前需要学习的。&lt;/p&gt;

&lt;h2 id=&quot;containers-容器&quot;&gt;Containers (容器)&lt;/h2&gt;

&lt;p&gt;容器就是我们之前将的docker，或其他虚拟化容器。不过docker应该是主流。一般人认为容器应该是kubernets的最小单位，其实并不是它是组成最小的单位的主要成分。接下来要讲的Pod才是最小的kubernets组成单位。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://xiangdong1987.github.io/docker/2019/04/03/docker-local-registry.html&quot;&gt;如何搭建本地docker registry&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;pod-豆荚&quot;&gt;Pod (豆荚)&lt;/h2&gt;

&lt;p&gt;pod是组成kebernet的最小单位，每个pod中会包含一个或多个docker容器，为了管理pod的就引入了Replication controller.&lt;/p&gt;

&lt;h2 id=&quot;replication-controller-rc&quot;&gt;Replication Controller (RC)&lt;/h2&gt;

&lt;p&gt;副本控制器不明思议，就是管理副本的，副本的单位就是pod，随着程序的发展，RC已经被正在被Replication Set所替换，他们之间的区别RS堆label有更多的功能，可以利用表达式去匹配label标签。&lt;/p&gt;

&lt;h2 id=&quot;replication-set-rs&quot;&gt;Replication Set (RS)&lt;/h2&gt;

&lt;p&gt;跟RC相比它多了一些功能，对于selector 有更多的功能，可以使整个RS的意义更清晰，更能让维护人员理解。比如如下配置&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-angular2html&quot;&gt;apiVersion: extensions/v1beta1
 kind: ReplicaSet
 metadata:
   name: soaktestrs
 spec:
   replicas: 3
   selector:
     matchLabels:
       app: soaktestrs
   template:
     metadata:
       labels:
         app: soaktestrs
         environment: dev
     spec:
       containers:
       - name: soaktestrs
         image: nickchase/soaktest
         ports:
         - containerPort: 80
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;管是这样无法表这个服务到底是做什么用的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-angular2html&quot;&gt;...
spec:
   replicas: 3
   selector:
     matchExpressions:
      - {key: app, operator: In, values: [soaktestrs, soaktestrs, soaktest]}
      - {key: teir, operator: NotIn, values: [production]}
  template:
     metadata:
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以通过描述得到如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-angular2html&quot;&gt;
# kubectl create -f replicaset.yaml
replicaset &quot;soaktestrs&quot; created

# kubectl describe rs soaktestrs
Name:           soaktestrs
Namespace:      default
Image(s):       nickchase/soaktest
Selector:       app in (soaktest,soaktestrs),teir notin (production)
Labels:         app=soaktestrs
Replicas:       3 current / 3 desired
Pods Status:    3 Running / 0 Waiting / 0 Succeeded / 0 Failed
No volumes.
Events:
  FirstSeen     LastSeen        Count   From                            SubobjectPath   Type    Reason                   Message
  ---------     --------        -----   ----                            -------------   --------------                   -------
  1m            1m              1       {replicaset-controller }                        Normal  SuccessfulCreate Created pod: soaktestrs-it2hf
  1m            1m              1       {replicaset-controller }                       Normal  SuccessfulCreate Created pod: soaktestrs-kimmm
  1m            1m              1       {replicaset-controller }                        Normal  SuccessfulCreate Created pod: soaktestrs-8i4ra

# kubectl get pods
NAME               READY     STATUS    RESTARTS   AGE
soaktestrs-8i4ra   1/1       Running   0          1m
soaktestrs-it2hf   1/1       Running   0          1m
soaktestrs-kimmm   1/1       Running   0          1m
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;deployment&quot;&gt;Deployment&lt;/h2&gt;

&lt;p&gt;Deployment以RC做为管理单元实现Roll updating 和 Roll Back,实现动态更新和回滚的功能。&lt;/p&gt;

&lt;h2 id=&quot;service&quot;&gt;Service&lt;/h2&gt;

&lt;p&gt;service 主要是在deployment的基础上，管理ip Port Dns ,并且自动实现负载均衡和调度。&lt;/p&gt;

&lt;h2 id=&quot;yaml的种类&quot;&gt;Yaml的种类&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Replication Controller&lt;/li&gt;
  &lt;li&gt;Replication Set&lt;/li&gt;
  &lt;li&gt;Deployment&lt;/li&gt;
  &lt;li&gt;Service&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;四中yaml是逐层递增的向上的上层依赖下层，实现一个层级。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;kubernets 的整理部署由上面的几个部分组成，副本的是为了实现系统稳定性，副本管理是为了实现环境的滚动更新和回滚，service是为了实现统一的网关入口和负载均衡。整体的架构就是如此，细节就是要在实践中不断的学习和积累了。&lt;/p&gt;</content><author><name></name></author><summary type="html">在学习编排之前，认识kubernets的各种组件是很重要的。他们之间的关系是怎么样的？如果构建一个合理的服务？都是要在开始之前需要学习的。</summary></entry><entry><title type="html">linux 高性能学习笔记9</title><link href="/linux/2019/04/02/linux-high-9.html" rel="alternate" type="text/html" title="linux 高性能学习笔记9" /><published>2019-04-02T00:00:00+08:00</published><updated>2019-04-02T00:00:00+08:00</updated><id>/linux/2019/04/02/linux-high-9</id><content type="html" xml:base="/linux/2019/04/02/linux-high-9.html">&lt;p&gt;同CUP管理一样，内存管理也是操作系统最核心的功能之。内存主要用来存储系统和应用程序的指令，数据，缓存等。&lt;/p&gt;

&lt;h2 id=&quot;内存映射&quot;&gt;内存映射&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;通常说的8G内存指的是物理内存也成主存&lt;/li&gt;
  &lt;li&gt;进程是不可以直接访问物理内存，只有cpu可以直接访问物理内存&lt;/li&gt;
  &lt;li&gt;大多数的主存都是动态随机访问内存（DRAM）&lt;/li&gt;
  &lt;li&gt;linux 为每个进程分配一个独立的虚拟地址空间，并且是连续的。&lt;/li&gt;
  &lt;li&gt;虚拟内存空间也被分为内核空间和用户空间。&lt;/li&gt;
  &lt;li&gt;根据cpu指令可以处理数据的最大长度32位和64位&lt;/li&gt;
  &lt;li&gt;32位cpu 最长寻址空间是4G  1G 系统空间 3G 用户空间&lt;/li&gt;
  &lt;li&gt;64位cpu 最长寻址空间是17179869184G
    &lt;ul&gt;
      &lt;li&gt;头128T 系统空间&lt;/li&gt;
      &lt;li&gt;位128T 用户空间&lt;/li&gt;
      &lt;li&gt;其他 其他空间&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;每个进程都有用户态和内核态，所有的虚拟内存加起来一定大于物理内存，所以并不是所有虚拟内存都分配物理内存，只有那些实际使用的虚拟内存才分配物理内存，并且分配后的物理内存，是通过 &lt;strong&gt;内存映射&lt;/strong&gt; 来管理的。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;img src=&quot;/images/6.png&quot; alt=&quot;设置1&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;MMU(Memory Management Unit)内存管理单元，用于存储页表&lt;/li&gt;
  &lt;li&gt;每个进程都有一个对应的页表来做内存映射&lt;/li&gt;
  &lt;li&gt;当虚拟地址在页表种查找不到地址时 &lt;strong&gt;缺页异常&lt;/strong&gt; 进入内核空间分配物理内存，更新进程页表，最后返回用户空间，恢复进程运行。&lt;/li&gt;
  &lt;li&gt;MMU的最小单位是4KB称作&lt;strong&gt;页&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;由于页大小只有4KB，加入在32位系统中，就会有100多万的页表才能实现整个地址空间的映射。为了解决页表项过多的问题，linux提供两种机制
    &lt;ul&gt;
      &lt;li&gt;多级页表：吧内存分成区块来管理，讲原来的映射关系改成区块索引和区块内的偏移。由于虚拟内存空间通常只用很少一部分，那么多级页表就只保存这些使用中的区块，这样就可以大大地减少页表的项数&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;/images/7.png&quot; alt=&quot;设置1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;大页：不明思议就是更大的内存块，常见2MB和1GB，多用于使用大量内存的进程上，比如Oracle,DPDK等&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;虚拟内存空间的分布&quot;&gt;虚拟内存空间的分布&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;img src=&quot;/images/8.png&quot; alt=&quot;设置1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;从低到高分五种不同的内存段：
    &lt;ol&gt;
      &lt;li&gt;只读段，包括代码和常量等&lt;/li&gt;
      &lt;li&gt;数据段，包括全局变量等&lt;/li&gt;
      &lt;li&gt;堆，包括动态分配的内存，从低地址开始向上增长&lt;/li&gt;
      &lt;li&gt;文件映射段，包括动态库，共享内存等，从高地址开始向下增长&lt;/li&gt;
      &lt;li&gt;栈，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是8MB&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;内存分配与回收&quot;&gt;内存分配与回收&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;c语言使用malloc()方法分配内存
    &lt;ul&gt;
      &lt;li&gt;brk() 在c 标准库中当分配的内存小于128K默认使用brk()，当使用完成后并不会直接释放，而是缓存起来继续使用
        &lt;ul&gt;
          &lt;li&gt;缺点：在系统繁忙时容易产生内存碎片&lt;/li&gt;
          &lt;li&gt;优点：可以减少缺页异常的发生&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;mmap() 在大于128K使用mmap()分配内存
        &lt;ul&gt;
          &lt;li&gt;缺点：频繁的分配内存，容易产生缺页异常&lt;/li&gt;
          &lt;li&gt;优点：直接释放内存&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;对于内存来说，如果只分配而不释放，就会造成内存泄漏，甚至会耗尽内存。所有应用程序使用完内存后，还需要调用free()或unmap(),来释放这些不用的内存。&lt;/li&gt;
  &lt;li&gt;系统自身也不会任由应用程序的进程用完所有内存的，在发现内存紧张时，系统就会通过一系列机制来回收内存，比如下面这三种方式：
    &lt;ul&gt;
      &lt;li&gt;回收缓存，比如使用LRU算法，回收最近使用最少的内存页&lt;/li&gt;
      &lt;li&gt;回收不常访问的内存，把不常用的内存通过交换分区直接写到磁盘中（会使用交换分区Swap）&lt;/li&gt;
      &lt;li&gt;杀死进程，内存紧张时系统还会通过OOM(Out of Memory),直接杀掉占用大量内存的进程。
        &lt;ul&gt;
          &lt;li&gt;是一种内核保护机制&lt;/li&gt;
          &lt;li&gt;使用oom_score记录每个进程的使用内存评分&lt;/li&gt;
          &lt;li&gt;一个进程消耗的内存越大，oom_score就越大&lt;/li&gt;
          &lt;li&gt;一个进程运行占用的CPU越多，oom_score就越小&lt;/li&gt;
          &lt;li&gt;管理员可以手动设置oom_adj,oom_adj的范围[-17,15] 数值越大，表示进程越容易被OOM杀死，-17表示禁止OOM&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;如何查看内存使用情况&quot;&gt;如何查看内存使用情况&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;free 查看内存使用情况
    &lt;ul&gt;
      &lt;li&gt;total 是内存总大小&lt;/li&gt;
      &lt;li&gt;used 已使用的内存的大小，包好了共享内存&lt;/li&gt;
      &lt;li&gt;free 是未使用内存的大小&lt;/li&gt;
      &lt;li&gt;shared 是共享内存的大小&lt;/li&gt;
      &lt;li&gt;buff/cache 是缓存和缓冲区的大小&lt;/li&gt;
      &lt;li&gt;available 是进程可用内存的大小&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;top查看每个进程使用内存情况
    &lt;ul&gt;
      &lt;li&gt;VIRT 是进程虚拟内存的大小&lt;/li&gt;
      &lt;li&gt;RES 是常住内存的大小，进程实际使用物理内存的大小，不包含Swap和共享内存。&lt;/li&gt;
      &lt;li&gt;SHR 是共享内存的大小，比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等。&lt;/li&gt;
      &lt;li&gt;%MEM 是进程使用物理内存占系统内存的百分比&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;buffer-和-cache&quot;&gt;Buffer 和 Cache&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;通常理解buffer是写入时合并写入，加快写入速度的&lt;/li&gt;
  &lt;li&gt;通常理解cache是读取磁盘文件的页缓存，加快速度读取的&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;linux-文件系统&quot;&gt;linux 文件系统&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;在linux内所有一切皆文件&lt;/li&gt;
  &lt;li&gt;文件分为好多类型（ls -l /dev）：
    &lt;ul&gt;
      &lt;li&gt;-：普通文件&lt;/li&gt;
      &lt;li&gt;d: 目录&lt;/li&gt;
      &lt;li&gt;l：链接&lt;/li&gt;
      &lt;li&gt;d: 块文件&lt;/li&gt;
      &lt;li&gt;c: 字符串文件&lt;/li&gt;
      &lt;li&gt;s: socket文件&lt;/li&gt;
      &lt;li&gt;p: 管道文件&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;磁盘会分区块，系统在每个区块上建立文件系统，在文件系统下创建目录，在目录中创建文件。
    &lt;ul&gt;
      &lt;li&gt;普通文件就是目录中的文件，他的读写基于文件系统&lt;/li&gt;
      &lt;li&gt;块文件，就是磁盘空间，他的读写会跳过文件系统&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;对于以上的两种文件的读写，系统用了不同的优化方式
    &lt;ul&gt;
      &lt;li&gt;普通文件：cache&lt;/li&gt;
      &lt;li&gt;块文件：buffer&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;以上就是cache和buffer的本质区别。&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">同CUP管理一样，内存管理也是操作系统最核心的功能之。内存主要用来存储系统和应用程序的指令，数据，缓存等。</summary></entry><entry><title type="html">linux 高性能学习笔记8</title><link href="/linux/2019/03/29/linux-high-8.html" rel="alternate" type="text/html" title="linux 高性能学习笔记8" /><published>2019-03-29T16:39:26+08:00</published><updated>2019-03-29T16:39:26+08:00</updated><id>/linux/2019/03/29/linux-high-8</id><content type="html" xml:base="/linux/2019/03/29/linux-high-8.html">&lt;p&gt;针对cup瓶颈的问题分析了很多，相应的分析工具也介绍了不少，但理解了各种指标的含义后，会发现他们之间是有一定关联性的。顺着关联是可以很快找到瓶颈所在。找到瓶颈下一步就是进行优化。&lt;/p&gt;
&lt;h2 id=&quot;方法论&quot;&gt;方法论&lt;/h2&gt;
&lt;p&gt;可以从下面三个问题出发来判断性能优化是否有效&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;如何判断性能优化的有效性？&lt;/li&gt;
  &lt;li&gt;性能问题通常不是独立问的，如果同时发生先优化哪一个？&lt;/li&gt;
  &lt;li&gt;提升性能的方法并不唯一的，当有多钟选择时，改选哪一种？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果你能轻松的回答这三个问题就可以开始优化了&lt;/p&gt;
&lt;h3 id=&quot;细化三个问题&quot;&gt;细化三个问题&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;如何评估性能效果
    &lt;ol&gt;
      &lt;li&gt;确定性能的量化指标
        &lt;ul&gt;
          &lt;li&gt;cpu使用率&lt;/li&gt;
          &lt;li&gt;应用程序吞吐量&lt;/li&gt;
          &lt;li&gt;客户端请求的延迟
            &lt;blockquote&gt;
              &lt;p&gt;建议不要局限在单一纬度上来定指标
应用程序纬度：吞吐量和请求延迟
系统资源纬度：cpu使用率&lt;/p&gt;
            &lt;/blockquote&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;测试优化前的性能指标
        &lt;blockquote&gt;
          &lt;p&gt;注意：&lt;/p&gt;
          &lt;ol&gt;
            &lt;li&gt;尽量避免性能测试工具干扰应用程序的性能，防止交叉污染&lt;/li&gt;
            &lt;li&gt;避免外部环境的变化影响性能指标的评估&lt;/li&gt;
          &lt;/ol&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;测试优化后的性能指标&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;多个性能问题同时存在，要怎么选？
    &lt;ul&gt;
      &lt;li&gt;二八原则：80%的问题都是由20%的代码导致的，只要找到20%就可以了，&lt;em&gt;并不是所有的性能问题都值得优化&lt;/em&gt;
        &lt;ol&gt;
          &lt;li&gt;如果资源达到瓶颈，比如cpu使用率到了100%，那么首先优化一定是系统资源使用问题。优化后再考虑其他问题。&lt;/li&gt;
          &lt;li&gt;针对不同类型的指标，首先优化那些由瓶颈导致的，性能指标变化幅度最大的问题，比如产生瓶颈后，用户cpu使用率升高了10%，而系统cpu使用率却升高了50%，这个时候首先应该优化cpu使用率。&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;多种优化方法时，如何选择？
    &lt;ul&gt;
      &lt;li&gt;&lt;em&gt;性能优化并非没有成本&lt;/em&gt; 当你优化一个指标，有可能另一个指标却上升了。&lt;/li&gt;
      &lt;li&gt;比如网络优化中的DPDK（Data Plane Development Kit）提升网络的处理能力。它需要独占一个cpu以及一定数量的内存大页，CPU核数较少是并不适合用这种优化。
        &lt;h3 id=&quot;几大优化方向&quot;&gt;几大优化方向&lt;/h3&gt;
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* CPU优化
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;应用程序优化：排除所有不必要的工作，只保留核心的逻辑。比如减少循环层次，减少递归，减少动态内存分配等等
        &lt;ul&gt;
          &lt;li&gt;编译器优化：gcc&lt;/li&gt;
          &lt;li&gt;算法优化：减少算法复杂度&lt;/li&gt;
          &lt;li&gt;异步处理：轮训改为事件通知&lt;/li&gt;
          &lt;li&gt;多线程代替多进程：减少上下文切换&lt;/li&gt;
          &lt;li&gt;善用缓存：减少磁盘操作，直接使用缓存&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;系统优化：
        &lt;ul&gt;
          &lt;li&gt;cpu绑定：把进程绑定到一个或者多个cpu上，可以提高cpu缓存命中率，减少跨cpu调度带来的上下文切换&lt;/li&gt;
          &lt;li&gt;cpu独占：类似绑定，独占cpu&lt;/li&gt;
          &lt;li&gt;优先级调整：减低非核心业务的应用优先级&lt;/li&gt;
          &lt;li&gt;为进程设置资源限制：使用linux cgroups 来设置进程的cpu使用上线。&lt;/li&gt;
          &lt;li&gt;NUMA(Non-Uniform Memory Access)优化：支持NUMA的cup，会被划分为多个node,每个都有自己的本地内存地址。&lt;/li&gt;
          &lt;li&gt;中断负载均衡：开启irqbalance服务或者配置smp_affinity,把中断处理自动负载均衡到多个cpu
            &lt;blockquote&gt;
              &lt;p&gt;注意:
&lt;em&gt;避免过早优化&lt;/em&gt;：&lt;/p&gt;
              &lt;ol&gt;
                &lt;li&gt;优化带来复杂性的提升，降低可维护性。&lt;/li&gt;
                &lt;li&gt;需求是动态变化的，要针对当前情况进行优化，是个动态的过程。&lt;/li&gt;
              &lt;/ol&gt;
            &lt;/blockquote&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">针对cup瓶颈的问题分析了很多，相应的分析工具也介绍了不少，但理解了各种指标的含义后，会发现他们之间是有一定关联性的。顺着关联是可以很快找到瓶颈所在。找到瓶颈下一步就是进行优化。 方法论 可以从下面三个问题出发来判断性能优化是否有效 如何判断性能优化的有效性？ 性能问题通常不是独立问的，如果同时发生先优化哪一个？ 提升性能的方法并不唯一的，当有多钟选择时，改选哪一种？</summary></entry><entry><title type="html">kubernets理解总结</title><link href="/kubernets/2019/03/28/kubernets-1.html" rel="alternate" type="text/html" title="kubernets理解总结" /><published>2019-03-28T00:00:00+08:00</published><updated>2019-03-28T00:00:00+08:00</updated><id>/kubernets/2019/03/28/kubernets-1</id><content type="html" xml:base="/kubernets/2019/03/28/kubernets-1.html">&lt;p&gt;总体理解kubernets架构以及各个结构中的api使用&lt;/p&gt;

&lt;h2 id=&quot;node&quot;&gt;Node&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;节点：可以使虚拟机，也可以是实体机&lt;/li&gt;
  &lt;li&gt;每个节点上都安装kubernets&lt;/li&gt;
  &lt;li&gt;有主节点和子节点的区分&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;pods&quot;&gt;Pods&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;是组成节点的最小单位，是任意独立的容器,pos都存储在Node中，每个pos有自己的功能&lt;/li&gt;
  &lt;li&gt;获取Pods&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    kubectl get pods
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;查看Pods 描述&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    kubectl describe deployment
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;进入pods中&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    kubectl exec -ti $POD_NAME
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;service&quot;&gt;Service&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;通过service向外暴露pods&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    kubectl expose deployment/kubernetes-bootcamp --type=&quot;NodePort&quot; --port 8080
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;查看service&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    kubectl get services
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;查看service描述&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    kubectl describe services/kubernetes-bootcamp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;根据标签删除services&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    kubectl delete service -l run=kubernetes-bootcamp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;label&quot;&gt;Label&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;每个部署的pods 都会自动创建标签&lt;/li&gt;
  &lt;li&gt;通过标签查询pods&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    kubectl get pods -l kubectl describe deployment
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;重新设置标签&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    kubectl label pod $POD_NAME app=v1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;scale&quot;&gt;Scale&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;自动扩容缩容
    &lt;ul&gt;
      &lt;li&gt;各种状态
        &lt;ol&gt;
          &lt;li&gt;DESIRED 想要的容器数量&lt;/li&gt;
          &lt;li&gt;CURRENT 当前的数量&lt;/li&gt;
          &lt;li&gt;UP-TO-DATE ？？&lt;/li&gt;
          &lt;li&gt;AVAILABLE 有效的&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    kubectl scale deployments/kubernetes-bootcamp --replicas=4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;rolling-update&quot;&gt;Rolling Update&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;滚动更新
    &lt;ul&gt;
      &lt;li&gt;通过镜像更新pods&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=jocatalin/kubernetes-bootcamp:v2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;检查滚动更新状态&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    kubectl rollout status deployments/kubernetes-bootcamp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">总体理解kubernets架构以及各个结构中的api使用</summary></entry><entry><title type="html">Github免费博客空间</title><link href="/blog/2019/03/26/jekyll-blog.html" rel="alternate" type="text/html" title="Github免费博客空间" /><published>2019-03-26T16:39:26+08:00</published><updated>2019-03-26T16:39:26+08:00</updated><id>/blog/2019/03/26/jekyll-blog</id><content type="html" xml:base="/blog/2019/03/26/jekyll-blog.html">&lt;p&gt;本来想自己买服务器，搭建自己的博客，突然google到一种不用服务器也可以做自己博客的方式，利用github pages搭建自己的博客个人实践，完全可行。步骤如下：&lt;/p&gt;

&lt;h3 id=&quot;创建代码库&quot;&gt;创建代码库&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;创建一个自己的代码库blog&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;注意下面两个设置&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/1.png&quot; alt=&quot;设置1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2.png&quot; alt=&quot;设置1&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;安装环境&quot;&gt;安装环境&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;安装ruby(已安装跳过)&lt;/li&gt;
  &lt;li&gt;安装jekyll
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#安装jekyll 
gem install bundler jekyll
#新建jekyll羡慕
jekyll new my_blog
cd my_blog
#开启本地服务
bundle exec jekyll serve
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;我是使用vm虚拟机为了方便本地调试，利用反向代理本地服务
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server {
  listen 80;
  server_name ytiamo.com;
  location /{
      proxy_pass http://127.0.0.1:4000;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;补充知识点可以利用参数-H 来指定主机
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bundle exec jekyll serve -H 192.168.112.20
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;注意：代码库目录和jekyll代码目录是不同目录，最后将代码库目录更新到github&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;博客撰写&quot;&gt;博客撰写&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;从远端拉取自己的代码库
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/xxxxxx/blog.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;构建部署&quot;&gt;构建部署&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;构建代码到你的到blog目录
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jekyll build --destination ../blog/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;推送代码到远端&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">本来想自己买服务器，搭建自己的博客，突然google到一种不用服务器也可以做自己博客的方式，利用github pages搭建自己的博客个人实践，完全可行。步骤如下：</summary></entry></feed>