<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2019-05-24T13:41:21+08:00</updated><id>/feed.xml</id><title type="html">一叶障目</title><subtitle>学无止境</subtitle><entry><title type="html">Go学习笔记9</title><link href="/go/2019/05/24/Go-9.html" rel="alternate" type="text/html" title="Go学习笔记9" /><published>2019-05-24T00:00:00+08:00</published><updated>2019-05-24T00:00:00+08:00</updated><id>/go/2019/05/24/Go-9</id><content type="html" xml:base="/go/2019/05/24/Go-9.html">&lt;p&gt;包是为了减少重复造轮子，为开发人员减少心智的设计，允许程序员开发公用包或者自己私用的包，减少重复的造轮子。测试也程序员面对的重大问题之一，从我以一个php程序员的角度来看，Go语言的测试工具的设计上也是完爆php，一个成熟的语言测试工具真的是必不可少的。&lt;/p&gt;

&lt;h2 id=&quot;包和工具&quot;&gt;包和工具&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Go一共有100多个标准包可以用下面命令来查看：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;go list std | wc -l
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Go 包编译的特点
    &lt;ul&gt;
      &lt;li&gt;所有的包的导入都要在文件的开头声明，不需要分析整个代码直接编译特定包&lt;/li&gt;
      &lt;li&gt;不允许有循环引入，实现一个有向五环图，加快编译速度，也可以实现单包并发编译&lt;/li&gt;
      &lt;li&gt;编译后的目标文件不仅会导出信息，还记录了包的依赖关系，不需要遍历文件&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;导入路径：都是用字符串表示，由构建起进行解析。&lt;/li&gt;
  &lt;li&gt;包声明：在默认情况下导入包的包名是导入路径的最后一部分，但是也有特殊情况
    &lt;ul&gt;
      &lt;li&gt;main包和导入路径无关，主要是让go build 生成可执行文件&lt;/li&gt;
      &lt;li&gt;_test文件，构建器会忽略当前文件&lt;/li&gt;
      &lt;li&gt;带有版本号的包，也会忽略版本号。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;导入声明可以单独import 也可以用（）来包裹所有包，用换行还可以进行分组，分组中会按照顺序编译。&lt;/li&gt;
  &lt;li&gt;包的匿名导入，如果包不被使用但被导入，编译时会产生错误，但有时候程序设计上需要根据参数导入不同的包，这个时候需要先导入才能使用，所以使用import _ “image/png” 匿名导入的方式，来实现程序功能。&lt;/li&gt;
  &lt;li&gt;包的命名尽量简短，但也不要有歧义，最好拿最主要的实体命名&lt;/li&gt;
  &lt;li&gt;工具：
    &lt;ul&gt;
      &lt;li&gt;有瑞士军刀风格go hlep来看功能&lt;/li&gt;
      &lt;li&gt;在构建之前，工程目录也是要先设置好的&lt;/li&gt;
      &lt;li&gt;go build 会将程序构建到工程目录的 bin 目录下&lt;/li&gt;
      &lt;li&gt;Go 有健全的文档机制，只要我们在导出的函数前，完成注释即可，第一行是摘要，保持简洁，后面的可以任意长度，如果过长也可以单独文件doc.go 文件。&lt;/li&gt;
      &lt;li&gt;godoc 可以生成也浏览的html 页面方便查询。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;普通测试
    &lt;ul&gt;
      &lt;li&gt;_test.go 为文件名的文件，使用go test进行测试&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;测试覆盖率
    &lt;ul&gt;
      &lt;li&gt;覆盖率只是帮助找到代码脆弱的部分&lt;/li&gt;
      &lt;li&gt;go test -v -run=Coverage gopl.io/ch7/eval&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;基准测试
    &lt;ul&gt;
      &lt;li&gt;Benchmark为前缀的&lt;/li&gt;
      &lt;li&gt;测试一个程序在固定工作负载下的性能。&lt;/li&gt;
      &lt;li&gt;go test -bench=. -benchmem&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;性能测试
    &lt;ul&gt;
      &lt;li&gt;对于cpu 阻塞 和 内存的使用都可以用go test 进行测试。
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ go test -cpuprofile=cpu.out
  $ go test -blockprofile=block.out
  $ go test -memprofile=mem.out
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;Go 的包设计和工具的设计都是为了更好的方便程序员代码的开发和合理的利用，这种设计思想只有多年从事coder的人才能体会其中的妙用，测试也是解放了我们debug的时间，我觉得程序员都是懒的，只有懒才能触发我们的创造力，解放我们的时间，让我们有更多的时间做创造性的工作。&lt;/p&gt;</content><author><name></name></author><summary type="html">包是为了减少重复造轮子，为开发人员减少心智的设计，允许程序员开发公用包或者自己私用的包，减少重复的造轮子。测试也程序员面对的重大问题之一，从我以一个php程序员的角度来看，Go语言的测试工具的设计上也是完爆php，一个成熟的语言测试工具真的是必不可少的。</summary></entry><entry><title type="html">Go学习笔记8</title><link href="/go/2019/05/15/Go-8.html" rel="alternate" type="text/html" title="Go学习笔记8" /><published>2019-05-15T00:00:00+08:00</published><updated>2019-05-15T00:00:00+08:00</updated><id>/go/2019/05/15/Go-8</id><content type="html" xml:base="/go/2019/05/15/Go-8.html">&lt;p&gt;前面的学习，只学习了直接使用goroutine和channel的并发程序，忽略其他细微问题，尤其在包含共享变量的并发程序，接下来我们来学习，有共享变量的并发程序。&lt;/p&gt;

&lt;h2 id=&quot;竞争条件&quot;&gt;竞争条件&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;一般情况下我们没法去知道分别位于两个goroutine的事件x和y的执行顺序，x是在y之前还是之后还是同时发生是没法判断的。当我们能够没有办法自信地确认一个事件是在另一个事件的前面或者后面发生的话，就说明x和y这两个事件是并发的。
    &lt;ul&gt;
      &lt;li&gt;并发安全：一个函数在线性程序中可以正确地工作。如果在并发的情况下，这个函数依然可以正确地工作的话，那么我们就说这个函数是并发安全的，并发安全的函数不需要额外的同步工作&lt;/li&gt;
      &lt;li&gt;非并发安全：反之。单并发非安全的程序也可以通过某些方式变成线程安全的，并发安全的类型是例外，而不是规则，所以只有当文档中明确地说明了其是并发安全的情况下，你才可以并发地去访问它
        &lt;blockquote&gt;
          &lt;p&gt;导出包级别的函数一般情况下都是并发安全的。由于package级的变量没法被限制在单一的gorouine，所以修改这些变量“必须”使用互斥条件。&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;竞争条件：竞争条件指的是程序在多个goroutine交叉执行操作时，没有给出正确的结果。竞争条件是很恶劣的一种场景，因为这种问题会一直潜伏在你的程序里，然后在非常少见的时候蹦出来，或许只是会在很大的负载时才会发生，又或许是会在使用了某一个编译器、某一种平台或者某一种架构的时候才会出现。这些使得竞争条件带来的问题非常难以复现而且难以分析诊断。&lt;/li&gt;
  &lt;li&gt;如何避免竞争条件
    &lt;ul&gt;
      &lt;li&gt;第一种方法是不要去写变量。（不太可能）&lt;/li&gt;
      &lt;li&gt;第二种避免数据竞争的方法是，避免从多个goroutine访问变量。&lt;/li&gt;
      &lt;li&gt;第三种避免数据竞争的方法是允许很多goroutine去访问变量，但是在同一个时刻最多只有一个goroutine在访问。这种方式被称为“互斥”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;syncmutex互斥锁&quot;&gt;sync.Mutex互斥锁&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;前面学习的时候我们可以利用buffer channel控制gorontine的深度，如果我们用buffer等于的channel 就可以控制变量的访问如下代码：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var (
    sema    = make(chan struct{}, 1) // a binary semaphore guarding balance
    balance int
)

func Deposit(amount int) {
    sema &amp;lt;- struct{}{} // acquire token
    balance = balance + amount
    &amp;lt;-sema // release token
}

func Balance() int {
    sema &amp;lt;- struct{}{} // acquire token
    b := balance
    &amp;lt;-sema // release token
    return b
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;这种互斥很实用，而且被sync包里的Mutex类型直接支持。它的Lock方法能够获取到token(这里叫锁)，并且Unlock方法会释放这个token&lt;/li&gt;
  &lt;li&gt;在锁之间的区域叫做临界区，为了使用临界区的临界关闭正确一般我会选择使用defer来控制临界区的关闭。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func Balance() int {
    mu.Lock()
    defer mu.Unlock()
    return balance
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Go 是没有重入锁的（java中是有重入锁：锁上锁）关于Go的互斥量不能重入这一点我们有很充分的理由。互斥量的目的是为了确保共享变量在程序执行时的关键点上能够保证不变性。不变性的其中之一是“没有goroutine访问共享变量”。&lt;/li&gt;
  &lt;li&gt;所以在包的封装上，一个通用的解决方案是将一个函数分离为多个函数，比如我们把Deposit分离成两个：一个不导出的函数deposit，这个函数假设锁总是会被保持并去做实际的操作，另一个是导出的函数Deposit，这个函数会调用deposit，但在调用前会先去获取锁。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;syncrwmutex读写锁&quot;&gt;sync.RWMutex读写锁&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;利用互斥锁，会将变量的读也锁住，如果系统中包含大量的读操作，互斥锁就完全限制了系统的功能。所以Go支持读写锁，只有在写的时候会锁定。&lt;/li&gt;
  &lt;li&gt;RWMutex只有当获得锁的大部分goroutine都是读操作，而锁在竞争条件下，也就是说，goroutine们必须等待才能获取到锁的时候，RWMutex才是最能带来好处的。RWMutex需要更复杂的内部记录，所以会让它比一般的无竞争锁的mutex慢一些
    &lt;h2 id=&quot;synconce初始化&quot;&gt;sync.Once初始化&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;有些时候当我们初始化一些慢操作时，如果不使用锁机制进行控制的话，会造成非并发安全的情况。所以时候需要同时使用互斥锁和读写锁&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var mu sync.RWMutex // guards iconsvar icons map[string]image.Image
// Concurrency-safe.func Icon(name string) image.Image {
    mu.RLock()
    if icons != nil {
        icon := icons[name]
        mu.RUnlock()
        return icon
    }
    mu.RUnlock()

    // acquire an exclusive lock
    mu.Lock()
    if icons == nil { // NOTE: must recheck for nil
        loadIcons()
    }
    icon := icons[name]
    mu.Unlock()
    return icon
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;这样写比较麻烦所以Go使用了sync.Once简化了整个流程&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var loadIconsOnce sync.Once
var icons map[string]image.Image
// Concurrency-safe.
func Icon(name string) image.Image {
    loadIconsOnce.Do(loadIcons)
    return icons[name]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;竞争条件检测&quot;&gt;竞争条件检测&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;即使我们小心到不能再小心，但在并发程序中犯错还是太容易了。幸运的是，Go的runtime和工具链为我们装备了一个复杂但好用的动态分析工具，竞争检查器(the race detector)。只要在go build，go run或者go test命令后面加上-race的flag，就会使编译器创建一个你的应用的“修改”版或者一个附带了能够记录所有运行期对共享变量访问工具的test，并且会记录下每一个读或者写共享变量的goroutine的身份信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;并发无阻塞&quot;&gt;并发无阻塞&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;想实现并发无阻塞，必须避免竞争条件的产生。一下实现了一个并发无阻塞的缓存。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type entry struct {
    res   result
    ready chan struct{} // closed when res is ready
}

func New(f Func) *Memo {
    return &amp;amp;Memo{f: f, cache: make(map[string]*entry)}
}

type Memo struct {
    f     Func
    mu    sync.Mutex // guards cache
    cache map[string]*entry
}

func (memo *Memo) Get(key string) (value interface{}, err error) {
    memo.mu.Lock()
    e := memo.cache[key]
    if e == nil {
        // This is the first request for this key.
        // This goroutine becomes responsible for computing
        // the value and broadcasting the ready condition.
        e = &amp;amp;entry{ready: make(chan struct{})}
        memo.cache[key] = e
        memo.mu.Unlock()

        e.res.value, e.res.err = memo.f(key)

        close(e.ready) // broadcast ready condition
    } else {
        // This is a repeat request for this key.
        memo.mu.Unlock()

        &amp;lt;-e.ready // wait for ready condition
    }
    return e.res.value, e.res.err
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;以上利用ready channel 实现了读广播，变量是否准备完毕。使用特性是当一个无buffer的channel会阻塞读取channel的代码位置，当关闭channel时，是会通知到读取的地方channel已经关闭，并不产生错误（但是向已经关闭的channel，传输数据会产生painc）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;goroutine和线程&quot;&gt;Goroutine和线程&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;栈空间的区别
    &lt;ul&gt;
      &lt;li&gt;线程的栈是固定大小的2m&lt;/li&gt;
      &lt;li&gt;Goroutine初始是2k，可以根据程序的变化动态改变，最大有1GB，在Go中叫动态栈。
        &lt;blockquote&gt;
          &lt;p&gt;知识点：
栈：一个栈的作用是用来保存函数调用上下文和内部变量&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;调度的区别
    &lt;ul&gt;
      &lt;li&gt;线程间的切换时需要保存线程上下文，切换到替他线程，是利用系统的shedule函数，由cup来调度。&lt;/li&gt;
      &lt;li&gt;Goruntine的切换是在，go Runtime 中实现的，由Go本身控制调度，并且采用了一种n:m的方式，利用n个系统线程分别处理m个Goruntine，所以一个goruntine的切换消耗比线程小的多
        &lt;blockquote&gt;
          &lt;p&gt;线程相比Goroutine它多调用了局部内存，增加了cpu运行周期（由于切换和读内存引起的）
Goruntine 的调度方式也类似系统的调度方式
GOMAXPROCS 参数是用来设定Go用多少个系统线程同时工作。&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;自身标识
    &lt;ul&gt;
      &lt;li&gt;线程是有线程id的&lt;/li&gt;
      &lt;li&gt;Goruntine是没有的，原因是防止由于thread-local storage（TLS）总是会被滥用，所引起的过分依赖线程的局部变量，程序变幻莫测。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结：&lt;/h2&gt;
&lt;p&gt;并发带来的问题就是，竞争条件，如果竞争条件不处理好，会造成意料不到的结果。所以并发主要处理的就是竞争条件问题，处理竞争条件主要有如下三个方向：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;避免写操作&lt;/li&gt;
  &lt;li&gt;避免从多个goroutine，写入数据&lt;/li&gt;
  &lt;li&gt;允许多个goruntine访问一个变量，但是同一时刻只能有一个能访问，就是互斥
第一种方式，使用的场景特别少，只有少量静态服务才会这样使用。
第二种方式，在设计时，由一个主Goruntine去处理些操作，其他Goruntine作为生产者利用channel处理
第三种方式，允许多个Goruntine写变量，但是同一时刻只能有一个可以生效，利用互斥锁+channel广播的形式实现并发非阻塞
Go实现并发的优势主要是在goruntine和线程的区别和自身的runtime并发调度，优化了线程调度之间的损耗，实现了更高效的并发。&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">前面的学习，只学习了直接使用goroutine和channel的并发程序，忽略其他细微问题，尤其在包含共享变量的并发程序，接下来我们来学习，有共享变量的并发程序。</summary></entry><entry><title type="html">Go学习笔记7</title><link href="/go/2019/05/09/Go-7.html" rel="alternate" type="text/html" title="Go学习笔记7" /><published>2019-05-09T00:00:00+08:00</published><updated>2019-05-09T00:00:00+08:00</updated><id>/go/2019/05/09/Go-7</id><content type="html" xml:base="/go/2019/05/09/Go-7.html">&lt;p&gt;重头戏要来了，并发编程。这是Go的主打优势，Go通过自身设计层面，隐藏了比较晦涩难懂的并发过程，我们只需要通过goroutine和channel的配合就能实现自己想要的并发程序，实现CSP（communicating sequential processes）并发变成模型，像我这么懒得人特别喜欢站在巨人的肩膀上眺望。&lt;/p&gt;

&lt;h2 id=&quot;goroutines&quot;&gt;Goroutines&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;在Go语言中，每一个并发的执行单元叫作一个goroutine。&lt;/li&gt;
  &lt;li&gt;当一个程序启动时，其主函数即在一个单独的goroutine中运行，我们叫它main goroutine。新的goroutine会用go语句来创建。在语法上，go语句是一个普通的函数或方法调用前加上关键字go。go语句会使其语句中的函数在一个新创建的goroutine中运行。而go语句本身会迅速地完成。&lt;/li&gt;
  &lt;li&gt;Goroutines是并发体
    &lt;h2 id=&quot;channels&quot;&gt;Channels&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;如果说goroutine是Go语言程序的并发体的话，那么channels则是它们之间的通信机制。&lt;/li&gt;
  &lt;li&gt;channels 就是一个顺序的消息队列可分为下面两类
    &lt;ul&gt;
      &lt;li&gt;有buffer的channel:
        &lt;ul&gt;
          &lt;li&gt;读取时：队列非空不阻塞&lt;/li&gt;
          &lt;li&gt;写入时：队列非满不阻塞&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;有buffer示例代码：
  ```
  func mirroredQuery() string {
  responses := make(chan string, 3)
  go func() { responses &amp;lt;- request(“asia.gopl.io”) }()
  go func() { responses &amp;lt;- request(“europe.gopl.io”) }()
  go func() { responses &amp;lt;- request(“americas.gopl.io”) }()
  return &amp;lt;-responses // return the quickest response
  }&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;func request(hostname string) (response string) { /* … */ }
  ```&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;p&gt;如果我们使用了无缓存的channel，那么两个慢的goroutines将会因为没有人接收而被永远卡住。这种情况，称为goroutines泄漏，这将是一个BUG。和垃圾变量不同，泄漏的goroutines并不会被自动回收，因此确保每个不再需要的goroutine能正常退出是重要的。&lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;没有buffer的channel
          &lt;ul&gt;
            &lt;li&gt;读取时：有写入不阻塞&lt;/li&gt;
            &lt;li&gt;写入时：空channnel不阻塞&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;串联channnel实现pipeline。让各个程序同时并发处理&lt;/li&gt;
  &lt;li&gt;使用单方向的channel 避免一些异常写入和读取&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func counter(out chan&amp;lt;- int) {
    for x := 0; x &amp;lt; 100; x++ {
        out &amp;lt;- x
    }
    close(out)
}

func squarer(out chan&amp;lt;- int, in &amp;lt;-chan int) {
    for v := range in {
        out &amp;lt;- v * v
    }
    close(out)
}

func printer(in &amp;lt;-chan int) {
    for v := range in {
        fmt.Println(v)
    }
}

func main() {
    naturals := make(chan int)
    squares := make(chan int)
    go counter(naturals)
    go squarer(squares, naturals)
    printer(squares)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Channel的缓存也可能影响程序的性能。想象一家蛋糕店有三个厨师，一个烘焙，一个上糖衣，还有一个将每个蛋糕传递到它下一个厨师在生产线。在狭小的厨房空间环境，每个厨师在完成蛋糕后必须等待下一个厨师已经准备好接受它；这类似于在一个无缓存的channel上进行沟通。&lt;/li&gt;
  &lt;li&gt;合理的设置缓存，就是合理的利用生产者和消费者之间的关系。尽量不要过度生产或者过度消费&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;并发循环&quot;&gt;并发循环&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;利用循环迭代进行并发是最长见的并发模型，如果不在main gorouintine 进行控制程序会瞬间执行完毕，不等待其他goroutine 完成，所以一般我们会用channel进行控制代码如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// makeThumbnails3 makes thumbnails of the specified files in parallel.func makeThumbnails3(filenames []string) {
    ch := make(chan struct{})
    for _, f := range filenames {
        go func(f string) {
            thumbnail.ImageFile(f) // NOTE: ignoring errors
            ch &amp;lt;- struct{}{}
        }(f)
    }
    // Wait for goroutines to complete.
    for range filenames {
        &amp;lt;-ch
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;前面讲的都是知道并行次数的情况，在不知道并行次数的情况下我们需要一个完全的计数器来控制并行的结束，通过sync.WaitGroup来控制循环进程结束
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// makeThumbnails6 makes thumbnails for each file received from the channel.
// It returns the number of bytes occupied by the files it creates.
func makeThumbnails6(filenames &amp;lt;-chan string) int64 {
  sizes := make(chan int64)
  var wg sync.WaitGroup // number of working goroutines
  for f := range filenames {
      wg.Add(1)
      // worker
      go func(f string) {
          defer wg.Done()
          thumb, err := thumbnail.ImageFile(f)
          if err != nil {
              log.Println(err)
              return
          }
          info, _ := os.Stat(thumb) // OK to ignore error
          sizes &amp;lt;- info.Size()
      }(f)
  }

  // closer
  go func() {
      wg.Wait()
      close(sizes)
  }()

  var total int64
  for size := range sizes {
      total += size
  }
  return total
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;时序图如下：
&lt;img src=&quot;/images/11.png&quot; alt=&quot;设置1&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;实例分析&quot;&gt;实例分析&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;网络爬虫
    &lt;ul&gt;
      &lt;li&gt;工作channel,用于保存正在抓取的链接&lt;/li&gt;
      &lt;li&gt;接受命令行的goroutine&lt;/li&gt;
      &lt;li&gt;记录访问记录的map&lt;/li&gt;
      &lt;li&gt;循环消耗工作channel&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;优化思路
    &lt;ul&gt;
      &lt;li&gt;当无限开启goroutine时，会造打开过多的文件描述符，所以我们必须控制goroutine的数量，这个时候我们需要一个新的channel，token的channel,相当于令牌桶合理的有缓存channel 当做令牌桶,在go的函数获取令牌，执行结束后释放令牌。&lt;/li&gt;
      &lt;li&gt;如何防止无限抓取，要检查工作channel是否已经完成
        &lt;h2 id=&quot;多路复用select&quot;&gt;多路复用select&lt;/h2&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;当你有多个channel 想同时检测时你可以使用select，它保证随机的获取你要检测的channel代码如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
func main() {
    // ...create abort channel...

    fmt.Println(&quot;Commencing countdown.  Press return to abort.&quot;)
    tick := time.Tick(1 * time.Second)
    for countdown := 10; countdown &amp;gt; 0; countdown-- {
        fmt.Println(countdown)
        select {
        case &amp;lt;-tick:
            // Do nothing.
        case &amp;lt;-abort:
            fmt.Println(&quot;Launch aborted!&quot;)
            return
        }
    }
    launch()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;并发编程并不像，想象的那么难，也没有说的那么容易，其中很多方式方法还是需要在不断的学习和实践中总结比如：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;channel 有误buffer选用&lt;/li&gt;
  &lt;li&gt;goroutine 泄漏问题&lt;/li&gt;
  &lt;li&gt;goroutine 开启的限制&lt;/li&gt;
  &lt;li&gt;程序结束的限制&lt;/li&gt;
  &lt;li&gt;并发深度的限制等等
只有不断学习和实践才是做为一名coder 的终身事业。&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">重头戏要来了，并发编程。这是Go的主打优势，Go通过自身设计层面，隐藏了比较晦涩难懂的并发过程，我们只需要通过goroutine和channel的配合就能实现自己想要的并发程序，实现CSP（communicating sequential processes）并发变成模型，像我这么懒得人特别喜欢站在巨人的肩膀上眺望。</summary></entry><entry><title type="html">Go学习笔记6</title><link href="/go/2019/05/07/Go-6.html" rel="alternate" type="text/html" title="Go学习笔记6" /><published>2019-05-07T00:00:00+08:00</published><updated>2019-05-07T00:00:00+08:00</updated><id>/go/2019/05/07/Go-6</id><content type="html" xml:base="/go/2019/05/07/Go-6.html">&lt;p&gt;接口是对其他类型性的的抽象和概括，它没有具体的实现细节可以让我们的函数更加灵活和更具有适应能力。Go语言的接口独特之处是实现了隐式实现。只需要简单地拥有一些必须的方法就足够了。&lt;/p&gt;

&lt;h2 id=&quot;接口就是合约&quot;&gt;接口就是合约&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;通过定义接口来实现不同类型统一使用某种方法&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Writer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;format&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;format&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Stdout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;format&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Buffer&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;...)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;laravel中的facade也类似，利用了一个类型可以自由的使用另一个满足相同接口的类型来进行替换被称作可替换性(LSP里氏替换)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;接口类型&quot;&gt;接口类型&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Go源生包里的利用单方法接口实现LSP里氏替换&lt;/li&gt;
  &lt;li&gt;通过单方法接口拼装实现接口组合实现复杂功能&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;接口类型的实现&quot;&gt;接口类型的实现&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;接口指定的规则非常简单：表达一个类型属于某个接口只要这个类型实现这个接口&lt;/li&gt;
  &lt;li&gt;接口与接口之间可以直接复制，只要=右边的接口包含左边的接口就是成立的&lt;/li&gt;
  &lt;li&gt;指针类型也可以设定接口，是Go语言底层自己隐式寻址&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type IntSet struct { /* ... */ }
func (*IntSet) String() stringvar _ = IntSet{}.String() // compile error: String requires *IntSet receiver

var s IntSet
var _ = s.String() // OK: s is a variable and &amp;amp;s has a String method

var _ fmt.Stringer = &amp;amp;s // OK
var _ fmt.Stringer = s  // compile error: IntSet lacks String method
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;就像信封封装和隐藏信件起来一样，接口类型封装和隐藏具体类型和它的值。即使具体类型有其它的方法也只有接口类型暴露出来的方法会被调用到&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;os.Stdout.Write([]byte(&quot;hello&quot;)) // OK: *os.File has Write method
os.Stdout.Close()                // OK: *os.File has Close method

var w io.Writer
w = os.Stdout
w.Write([]byte(&quot;hello&quot;)) // OK: io.Writer has Write method
w.Close()                // compile error: io.Writer lacks Close method
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;空接口看上去好像没有用，但实际上interface{}被称为空接口类型是不可或缺的。因为空接口类型对实现它的类型没有要求，所以我们可以将任意一个值赋给空接口类型。&lt;/li&gt;
  &lt;li&gt;每一个具体类型的组基于它们相同的行为可以表示成一个接口类型。不像基于类的语言，他们一个类实现的接口集合需要进行显式的定义，在Go语言中我们可以在需要的时候定义一个新的抽象或者特定特点的组，而不需要修改具体类型的定义。当具体的类型来自不同的作者时这种方式会特别有用。当然也确实没有必要在具体的类型中指出这些共性。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;flagvalue-接口实践&quot;&gt;flag.Value 接口实践&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Celsius float64    // 摄氏温度
type Fahrenheit float64 // 华氏温度

const (
	AbsoluteZeroC Celsius = -273.15 // 绝对零度
	FreezingC     Celsius = 0       // 结冰点温度
	BoilingC      Celsius = 100     // 沸水温度
)

func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }

func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }
// *celsiusFlag satisfies the flag.Value interface.
func (c Celsius) String() string { return fmt.Sprintf(&quot;%g°C&quot;, c) }

type celsiusFlag struct{ Celsius }

func (f *celsiusFlag) Set(s string) error {
	var unit string
	var value float64
	fmt.Sscanf(s, &quot;%f%s&quot;, &amp;amp;value, &amp;amp;unit) // no error check needed
	switch unit {
	case &quot;C&quot;, &quot;°C&quot;:
		f.Celsius = Celsius(value)
		return nil
	case &quot;F&quot;, &quot;°F&quot;:
		f.Celsius = FToC(Fahrenheit(value))
		return nil
	}
	return fmt.Errorf(&quot;invalid temperature %q&quot;, s)
}

func CelsiusFlag(name string, value Celsius, usage string) *Celsius {
	f := celsiusFlag{value}
	flag.CommandLine.Var(&amp;amp;f, name, usage)
	return &amp;amp;f.Celsius
}

var temp = CelsiusFlag(&quot;temp&quot;, 20.0, &quot;the temperature&quot;)

func TestFlag() {
	flag.Parse()
	fmt.Println(*temp)
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;总结：其实接口就是不同类型之间的桥梁，将要使用的不同类型，通过接口类型实现相同的接口类型，从而在各异性的基础上又产生出相同的接口类型的共性，实现逻辑复用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;接口值&quot;&gt;接口值&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;概念上讲一个接口的值，接口值，由两个部分组成，一个具体的类型和那个类型的值。&lt;/li&gt;
  &lt;li&gt;在Go语言中，变量总是被一个定义明确的值初始化，即使接口类型也不例外。对于一个接口的零值就是它的类型和值的部分都是nil&lt;/li&gt;
  &lt;li&gt;零值接口时可以跟nil进行比较的来判断是否为零值接口&lt;/li&gt;
  &lt;li&gt;调用空接口上的任意方法都会产生panic&lt;/li&gt;
  &lt;li&gt;接口值可以使用＝＝和！＝来进行比较。两个接口值相等仅当它们都是nil值或者它们的动态类型相同并且动态值也根据这个动态类型的＝＝操作相等。因为接口值是可比较的，所以它们可以用在map的键或者作为switch语句的操作数，然而，如果两个接口值的动态类型相同，但是这个动态类型是不可比较的（比如切片），将它们进行比较就会失败并且panic。
考虑到这点，接口类型是非常与众不同的。其它类型要么是安全的可比较类型（如基本类型和指针）要么是完全不可比较的类型（如切片，映射类型，和函数），但是在比较接口值或者包含了接口值的聚合类型时，我们必须要意识到潜在的panic。同样的风险也存在于使用接口作为map的键或者switch的操作数。只能比较你非常确定它们的动态值是可比较类型的接口值。&lt;/li&gt;
  &lt;li&gt;一个不包含任何值的nil接口值和一个刚好包含nil指针的接口值是不同的&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const debug = true

func main() {
    var buf *bytes.Buffer
    if debug {
        buf = new(bytes.Buffer) // enable collection of output
    }
    f(buf) // NOTE: subtly incorrect!
    if debug {
        // ...use buf...
    }
}

// If out is non-nil, output will be written to it.func f(out io.Writer) {
    // ...do something...
    if out != nil {
        out.Write([]byte(&quot;done!\n&quot;))
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;重点参考的接口包&quot;&gt;重点参考的接口包&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;sort.Interface接口&lt;/li&gt;
  &lt;li&gt;http.Handler接口&lt;/li&gt;
  &lt;li&gt;error 接口&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;类型断言&quot;&gt;类型断言&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;类型断言是一个使用在接口值上的操作。语法上它看起来像x.(T)被称为断言类型，这里x表示一个接口的类型和T表示一个类型。一个类型断言检查它操作对象的动态类型是否和断言的类型匹配。
    &lt;ul&gt;
      &lt;li&gt;第一种，如果断言的类型T是一个具体类型，然后类型断言检查x的动态类型是否和T相同。如果这个检查成功了，类型断言的结果是x的动态值，当然它的类型是T。&lt;/li&gt;
      &lt;li&gt;第二种，如果相反断言的类型T是一个接口类型，然后类型断言检查是否x的动态类型满足T。如果这个检查成功了，动态值没有获取到；这个结果仍然是一个有相同类型和值部分的接口值，但是结果有类型T。&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;p&gt;注意：第二种的意思是指，一个类型可以使多种接口的组合，有时候需要扩大可访问方法，所以可以通过类型断言来改变接口类型，但是不改变接口的动态类性值。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;类型开关&quot;&gt;类型开关&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;利用switch做类型开关&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func sqlQuote(x interface{}) string {
    switch x := x.(type) {
    case nil:
        return &quot;NULL&quot;
    case int, uint:
        return fmt.Sprintf(&quot;%d&quot;, x) // x has type interface{} here.
    case bool:
        if x {
            return &quot;TRUE&quot;
        }
        return &quot;FALSE&quot;
    case string:
        return sqlQuoteString(x) // (not shown)
    default:
        panic(fmt.Sprintf(&quot;unexpected type %T: %v&quot;, x, x))
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;接口主要是学习设计的模式，如何用简单的不重复的代码写出通用性良好的程序，Go在语言设计层面做了很多文章，接口就是一个我认为非常重要的一种特性，它抽象整体的执行流程，只需将关键流程封装，在使用不同类型当参数时，以实现接口的方式来传入，实现类工厂模式你只需要按照接口的标准传入参数即可。&lt;em&gt;接口是不同包中类型的粘合剂&lt;/em&gt;，所以说在同一个包内如果没有必要不要过度抽象，过多的接口也会影响运行时效率。&lt;/p&gt;</content><author><name></name></author><summary type="html">接口是对其他类型性的的抽象和概括，它没有具体的实现细节可以让我们的函数更加灵活和更具有适应能力。Go语言的接口独特之处是实现了隐式实现。只需要简单地拥有一些必须的方法就足够了。</summary></entry><entry><title type="html">Go学习笔记5</title><link href="/go/2019/04/28/Go-5.html" rel="alternate" type="text/html" title="Go学习笔记5" /><published>2019-04-28T00:00:00+08:00</published><updated>2019-04-28T00:00:00+08:00</updated><id>/go/2019/04/28/Go-5</id><content type="html" xml:base="/go/2019/04/28/Go-5.html">&lt;p&gt;从90年代早期开始，面向对象编程(OOP)就成为了称霸工程界和教育界的编程范式，所以之后几乎所有大规模被应用的语言都包含了对OOP的支持，go语言也不例外。OOP编程的第一方面，我们会向你展示如何有效地定义和使用方法。我们会覆盖到OOP编程的两个关键点，封装和组合。&lt;/p&gt;

&lt;h2 id=&quot;方法声明&quot;&gt;方法声明&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;geometry&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;math&quot;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Y&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;float64&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;traditional&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;functionfunc&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;float64&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hypot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;same&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;but&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;typefunc&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;float64&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Hypot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;上面的代码里那个附加的参数p，叫做方法的接收器(receiver)，早期的面向对象语言留下的遗产将调用一个方法称为“向一个对象发送消息”。&lt;/li&gt;
  &lt;li&gt;在go语言中不适用this self做方法接收器，它建议适用类型的首字母作为接收器简短一致。&lt;/li&gt;
  &lt;li&gt;包级的方法不会跟类型的方法产生混乱&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // A Path is a journey connecting the points with straight lines.type Path []Point
    // Distance returns the distance traveled along the path.func (path Path) Distance() float64 {
        sum := 0.0
        for i := range path {
            if i &amp;gt; 0 {
                sum += path[i-1].Distance(path[i])
            }
        }
        return sum
    }
    
    perim := Path{
        {1, 1},
        {5, 1},
        {5, 4},
        {1, 1}
    }
    fmt.Println(perim.Distance()) // &quot;12&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;在上面两个对Distance名字的方法的调用中，编译器会根据方法的名字以及接收器来决定具体调用的是哪一个函数。第一个例子中path[i-1]数组中的类型是Point，因此Point.Distance这个方法被调用；在第二个例子中perim的类型是Path，因此Distance调用的是Path.Distance。&lt;/li&gt;
  &lt;li&gt;对于一个给定的类型，其内部的方法都必须有唯一的方法名，但是不同的类型却可以有同样的方法名，比如我们这里Point和Path就都有Distance这个名字的方法；所以我们没有必要非在方法名之前加类型名来消除歧义，比如PathDistance。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; import &quot;gopl.io/ch6/geometry&quot;
 perim := geometry.Path{
    {1, 1}, 
    {5, 1}, 
    {5, 4}, 
    {1, 1}
 }
 fmt.Println(geometry.PathDistance(perim)) // &quot;12&quot;, standalone function
 fmt.Println(perim.Distance())             // &quot;12&quot;, method of geometry.Path
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;如果我们要用方法去计算perim的distance，还需要去写全geometry的包名，和其函数名，但是因为Path这个变量定义了一个可以直接用的Distance方法，所以我们可以直接写perim.Distance()。相当于可以少打很多字，作者应该是这个意思。因为在Go里包外调用函数需要带上包名，还是挺麻烦的。
    &lt;h2 id=&quot;基于指针的对象方法&quot;&gt;基于指针的对象方法&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;不管你的method的receiver是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换。在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的内部，
    &lt;ul&gt;
      &lt;li&gt;第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；&lt;/li&gt;
      &lt;li&gt;第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝。熟悉C或者C艹的人这里应该很快能明白。
        &lt;h2 id=&quot;通过嵌入结构体来扩展类型&quot;&gt;通过嵌入结构体来扩展类型&lt;/h2&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;嵌入式写法，简化写代码时类型适用声明&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
import &quot;image/color&quot;

type Point struct{ X, Y float64 }

type ColoredPoint struct {
    Point
    Color color.RGBA
}

var cp ColoredPoint
cp.X = 1
fmt.Println(cp.Point.X) // &quot;1&quot;
cp.Point.Y = 2
fmt.Println(cp.Y) // &quot;2&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;对于Point中的方法我们也有类似的用法，我们可以把ColoredPoint类型当作接收器来调用Point里的方法，即使ColoredPoint里没有声明这些方法：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;red := color.RGBA{255, 0, 0, 255}
blue := color.RGBA{0, 0, 255, 255}
var p = ColoredPoint{Point{1, 1}, red}
var q = ColoredPoint{Point{5, 4}, blue}
fmt.Println(p.Distance(q.Point)) // &quot;5&quot;
p.ScaleBy(2)
q.ScaleBy(2)
fmt.Println(p.Distance(q.Point)) // &quot;10&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Point类的方法也被引入了ColoredPoint。用这种方式，内嵌可以使我们定义字段特别多的复杂类型，我们可以将字段先按小类型分组，然后定义小类型的方法，之后再把它们组合起来。
    &lt;blockquote&gt;
      &lt;p&gt;嵌入并不是代表继承的意思，更像是组合。并不是嵌入了某种类型这个类型类型就是某种类型的子类型，应该说是组合起来适用的更为合适。
如果想继承方法可以用匿名字段或者引用字段来做继承&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type ColoredPoint struct {
    *Point
    Color color.RGBA
}

p := ColoredPoint{&amp;amp;Point{1, 1}, red}
q := ColoredPoint{&amp;amp;Point{5, 4}, blue}
fmt.Println(p.Distance(*q.Point)) // &quot;5&quot;
q.Point = p.Point                 // p and q now share the same Point
p.ScaleBy(2)
fmt.Println(*p.Point, *q.Point) // &quot;{2 2} {2 2}&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;就是因为有了内嵌才有下面的小技巧：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var (
    mu sync.Mutex // guards mapping
    mapping = make(map[string]string)
)

func Lookup(key string) string {
    mu.Lock()
    v := mapping[key]
    mu.Unlock()
    return v
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;可以改写成如下：
```
var cache = struct {
  sync.Mutex
  mapping map[string]string
}{
  mapping: make(map[string]string),
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;func Lookup(key string) string {
    cache.Lock()
    v := cache.mapping[key]
    cache.Unlock()
    return v
}&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* 使代码更简洁更优雅

## 方法值和方法表达式

* 类型中的函数调用分两步
    * 用选择器选择方法，指定接收器
    * 根据接收器和参数返回方法值
* 我们可以根据不同的类型来决定用类型下的什么方法，通过指定不同接收器的方法，如下例子：
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;type Point struct{ X, Y float64 }&lt;/p&gt;

&lt;p&gt;func (p Point) Add(q Point) Point { return Point{p.X + q.X, p.Y + q.Y} }
func (p Point) Sub(q Point) Point { return Point{p.X - q.X, p.Y - q.Y} }&lt;/p&gt;

&lt;p&gt;type Path []Point&lt;/p&gt;

&lt;p&gt;func (path Path) TranslateBy(offset Point, add bool) {
    var op func(p, q Point) Point
    if add {
        op = Point.Add
    } else {
        op = Point.Sub
    }
    for i := range path {
        // Call either path[i].Add(offset) or path[i].Sub(offset).
        path[i] = op(path[i], offset)
    }
}
```&lt;/p&gt;

&lt;h2 id=&quot;封装&quot;&gt;封装&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;一个对象的变量或者方法如果对调用方是不可见的话，一般就被定义为“封装”。封装有时候也被叫做信息隐藏，同时也是面向对象编程最关键的一个方面。&lt;/li&gt;
  &lt;li&gt;封装的优点
    &lt;ul&gt;
      &lt;li&gt;首先，因为调用方不能直接修改对象的变量值，其只需要关注少量的语句并且只要弄懂少量变量的可能的值即可。&lt;/li&gt;
      &lt;li&gt;第二，隐藏实现的细节，可以防止调用方依赖那些可能变化的具体实现，这样使设计包的程序员在不破坏对外的api情况下能得到更大的自由。&lt;/li&gt;
      &lt;li&gt;第三个优点也是最重要的优点，是阻止了外部调用方对对象内部的值任意地进行修改。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;我们学到了如何将方法与命名类型进行组合，并且知道了如何调用这些方法。尽管方法对于OOP编程来说至关重要，但他们只是OOP编程里的半边天。为了完成OOP，我们还需要接口。Go里的接口会在接下来的学习中学习到。&lt;/p&gt;</content><author><name></name></author><summary type="html">从90年代早期开始，面向对象编程(OOP)就成为了称霸工程界和教育界的编程范式，所以之后几乎所有大规模被应用的语言都包含了对OOP的支持，go语言也不例外。OOP编程的第一方面，我们会向你展示如何有效地定义和使用方法。我们会覆盖到OOP编程的两个关键点，封装和组合。</summary></entry><entry><title type="html">Go学习笔记4</title><link href="/go/2019/04/26/Go-4.html" rel="alternate" type="text/html" title="Go学习笔记4" /><published>2019-04-26T00:00:00+08:00</published><updated>2019-04-26T00:00:00+08:00</updated><id>/go/2019/04/26/Go-4</id><content type="html" xml:base="/go/2019/04/26/Go-4.html">&lt;p&gt;函数是一组逻辑的集合，能把大的任务拆成一个一个小的任务，供软件的各个位置去调用。&lt;/p&gt;

&lt;h3 id=&quot;函数声明&quot;&gt;函数声明&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func name(parameter-list) (result-list) {
    body
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;参数列表：参数类型相同可以只在最后一个相同参数后面定义参数类型
    &lt;ul&gt;
      &lt;li&gt;形参与实参：按顺序赋值形参，只有当实参是引用类型，如指针，slice(切片)、map、function、channel等类型当做引用传递可以在函数内部修改实参的值，否则其他情况，形参只是实参的拷贝。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;返回值：返回值可以没有或者多个返回值，只有一个返回值时，可以只写一个返回值类型即可
```
func add(x int, y int) int   {return x + y}
func sub(x, y int) (z int)   { z = x - y; return}
func first(x int, _ int) int { return x }
func zero(int, int) int      { return 0 }&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;fmt.Printf(“%T\n”, add)   // “func(int, int) int”
fmt.Printf(“%T\n”, sub)   // “func(int, int) int”
fmt.Printf(“%T\n”, first) // “func(int, int) int”
fmt.Printf(“%T\n”, zero)  // “func(int, int) int”&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;### 递归
* 递归：函数自己调用自己就是递归调用。
* 大部分编程语言使用固定大小的函数调用栈，常见的大小从64KB到2MB不等。固定大小栈会限制递归的深度，当你用递归处理大量数据时，需要避免栈溢出；除此之外，还会导致安全性问题。与相反,Go语言使用可变栈，栈的大小按需增加(初始时很小)。这使得我们使用递归时不必考虑溢出和安全问题。
### 多指返回函数
* 惯例前面返回期望的值，最后一个返回erro值
* 不需要处理的返回值，用_来处理
* 如果在返回值列表里定义好了返回值的名字，可以用默认return。可以减少代码量，但是增加维护难度。不宜过度使用。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;// CountWordsAndImages does an HTTP GET request for the HTML
// document url and returns the number of words and images in it.
func CountWordsAndImages(url string) (words, images int, err error) {
    resp, err := http.Get(url)
    if err != nil {
        return
    }
    doc, err := html.Parse(resp.Body)
    resp.Body.Close()
    if err != nil {
        err = fmt.Errorf(“parsing HTML: %s”, err)
    return
    }
    words, images = countWordsAndImages(doc)
    return
}
func countWordsAndImages(n &lt;em&gt;html.Node) (words, images int) { /&lt;/em&gt; … */ }&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;### 错误
* go不将返回的erro 类型当初异常来处理，值当做预期的值来看待。
* go 错误处理策略
    * 第一种传播的方式
    * 第二种重试的方式：注意设置重试时间和次数
    * 第三种输出错误并退出：这种策略只应在main中执行。对库函数而言，应仅向上传播错误，除非该错误意味着程序内部包含不一致性，即遇到了bug，才能在库函数中结束程序
    * 第四种有时，我们只需要输出错误信息就足够了，不需要中断程序的运行。我们可以通过log包提供函数
    * 第五种，也是最后一种策略：我们可以直接忽略掉错误。
* 固定类型错误：io.EOF,可以根据错误信息执行特别的操作
### 函数值
* 在Go 语言中函数被定义为第一类值，有类型，可以被赋值给其他变量，传递个给函数。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;//利用函数变量便利html 标签&lt;/p&gt;

&lt;p&gt;// forEachNode针对每个结点x,都会调用pre(x)和post(x)。// pre和post都是可选的。// 遍历孩子结点之前,pre被调用// 遍历孩子结点之后，post被调用func forEachNode(n *html.Node, pre, post func(n *html.Node)) {
    if pre != nil {
        pre(n)
    }
    for c := n.FirstChild; c != nil; c = c.NextSibling {
        forEachNode(c, pre, post)
    }
    if post != nil {
        post(n)
    }
}&lt;/p&gt;

&lt;p&gt;var depth intfunc startElement(n &lt;em&gt;html.Node) {
    if n.Type == html.ElementNode {
        fmt.Printf(“%&lt;/em&gt;s&amp;lt;%s&amp;gt;\n”, depth&lt;em&gt;2, “”, n.Data)
        depth++
    }
}
func endElement(n *html.Node) {
    if n.Type == html.ElementNode {
        depth–
        fmt.Printf(“%&lt;/em&gt;s&amp;lt;/%s&amp;gt;\n”, depth*2, “”, n.Data)
    }
}&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;### 匿名函数
* 通过这种方式定义的函数可以访问完整的词法环境（lexical environment），这意味着在函数中定义的内部函数可以 **引用** 该函数的变量
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;// squares返回一个匿名函数。// 该匿名函数每次被调用时都会返回下一个数的平方。func squares() func() int {
    var x int
    return func() int {
        x++
        return x * x
    }
}
func main() {
    f := squares()
    fmt.Println(f()) // “1”
    fmt.Println(f()) // “4”
    fmt.Println(f()) // “9”
    fmt.Println(f()) // “16”
}&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* 利用匿名函数实现拓扑排序算法
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;// prereqs记录了每个课程的前置课程var prereqs = map[string][]string{
    “algorithms”: {“data structures”},
    “calculus”: {“linear algebra”},
    “compilers”: {
        “data structures”,
        “formal languages”,
        “computer organization”,
    },
    “data structures”:       {“discrete math”},
    “databases”:             {“data structures”},
    “discrete math”:         {“intro to programming”},
    “formal languages”:      {“discrete math”},
    “networks”:              {“operating systems”},
    “operating systems”:     {“data structures”, “computer organization”},
    “programming languages”: {“data structures”, “computer organization”},
}&lt;/p&gt;

&lt;p&gt;func main() {
    for i, course := range topoSort(prereqs) {
        fmt.Printf(“%d:\t%s\n”, i+1, course)
    }
}&lt;/p&gt;

&lt;p&gt;func topoSort(m map[string][]string) []string {
    var order []string
    seen := make(map[string]bool)
    var visitAll func(items []string)
    visitAll = func(items []string) {
        for _, item := range items {
            if !seen[item] {
                seen[item] = true
                visitAll(m[item])
                order = append(order, item)
            }
        }
    }
    var keys []string
    for key := range m {
        keys = append(keys, key)
    }
    sort.Strings(keys)
    visitAll(keys)
    return order
}&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* 利用匿名函数实现广度搜索
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;// breadthFirst calls f for each item in the worklist.
// Any items returned by f are added to the worklist.
// f is called at most once for each item.func 
breadthFirst(f func(item string) []string, worklist []string) {
    seen := make(map[string]bool)
    for len(worklist) &amp;gt; 0 {
        items := worklist
        worklist = nil
        for _, item := range items {
            if !seen[item] {
                seen[item] = true
                worklist = append(worklist, f(item)…)
            }
        }
    }
}&lt;/p&gt;

&lt;p&gt;func crawl(url string) []string {
    fmt.Println(url)
    list, err := links.Extract(url)
    if err != nil {
        log.Print(err)
    }
    return list
}&lt;/p&gt;

&lt;p&gt;func main() {
    // Crawl the web breadth-first,
    // starting from the command-line arguments.
    breadthFirst(crawl, os.Args[1:])
}&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* for的循环词法块中局部变量是引用的
### 可变参数函数
* 用...来做变量名，一般可变参数函数用来处理字符串
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;func errorf(linenum int, format string, args …interface{}) {
    fmt.Fprintf(os.Stderr, “Line %d: “, linenum)
    fmt.Fprintf(os.Stderr, format, args…)
    fmt.Fprintln(os.Stderr)
}
linenum, name := 12, “count”
errorf(linenum, “undefined: %s”, name) // “Line 12: undefined: count”&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;### Deferred函数
* defer语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。通过defer机制，不论函数逻辑多复杂，都能保证在任何执行路径下，资源被释放。释放资源的defer应该直接跟在请求资源的语句后。
* defer的声明是从前往后，触发是从后往前的触发
* 可以做调试函数
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;func bigSlowOperation() {
    defer trace(“bigSlowOperation”)() // don’t forget the
    extra parentheses
    // …lots of work…
    time.Sleep(10 * time.Second) // simulate slow
    operation by sleeping
}
func trace(msg string) func() {
    start := time.Now()
    log.Printf(“enter %s”, msg)
    return func() { 
        log.Printf(“exit %s (%s)”, msg,time.Since(start)) 
    }
}
```&lt;/p&gt;
&lt;h3 id=&quot;panic-异常&quot;&gt;Panic 异常&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;类似php throw 如果不捕获也会直接中断程序&lt;/li&gt;
  &lt;li&gt;一般只有严重错误，影响到程序的正常执行才会用到panic&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;recover捕获异常&quot;&gt;Recover捕获异常&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;无法捕获的情况
    &lt;ul&gt;
      &lt;li&gt;沒加recover的goroutine里panic&lt;/li&gt;
      &lt;li&gt;os.Exit&lt;/li&gt;
      &lt;li&gt;map 中特殊情况锁机制
        &lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
        &lt;p&gt;函数是程序逻辑的基本单位，是整个程序的基石，了解它的结构是，帮助我们写出合理优雅的代码的基础。总体来说Go的匿名函数给我比较深的印象，没想到用法可以大大减少代码量。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">函数是一组逻辑的集合，能把大的任务拆成一个一个小的任务，供软件的各个位置去调用。</summary></entry><entry><title type="html">Go学习笔记3</title><link href="/go/2019/04/22/Go-3.html" rel="alternate" type="text/html" title="Go学习笔记3" /><published>2019-04-22T00:00:00+08:00</published><updated>2019-04-22T00:00:00+08:00</updated><id>/go/2019/04/22/Go-3</id><content type="html" xml:base="/go/2019/04/22/Go-3.html">&lt;p&gt;Go数据类型有如下类型。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;基础类型&lt;/li&gt;
  &lt;li&gt;复合类型&lt;/li&gt;
  &lt;li&gt;引用类型&lt;/li&gt;
  &lt;li&gt;接口类型
类型内容很多只能慢慢学习，今天学习复合类型。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;复合类型&quot;&gt;复合类型&lt;/h2&gt;
&lt;h3 id=&quot;符合类型分类&quot;&gt;符合类型分类&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;固定长度
    &lt;ul&gt;
      &lt;li&gt;数组&lt;/li&gt;
      &lt;li&gt;结构体&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;动态长度
    &lt;ul&gt;
      &lt;li&gt;slice&lt;/li&gt;
      &lt;li&gt;map
        &lt;h3 id=&quot;类型详解&quot;&gt;类型详解&lt;/h3&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;数组：数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成
    &lt;ul&gt;
      &lt;li&gt;我们将会发现，数组、slice、map和结构体字面值的写法都很相似。是直接提供顺序初始化值序列，但是也可以指定一个索引和对应值列表的方式初始化，就像下面这样：
  ```
  type Currency int&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;const (
      USD Currency = iota // 美元
      EUR                 // 欧元
      GBP                 // 英镑
      RMB                 // 人民币
  )&lt;/p&gt;

    &lt;p&gt;symbol := […]string{USD: “$”, EUR: “€”, GBP: “￡”, RMB: “￥”}&lt;/p&gt;

    &lt;p&gt;fmt.Println(RMB, symbol[RMB]) // “3 ￥”&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  * 数组是可以直接比较的
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;import “crypto/sha256”&lt;/p&gt;

    &lt;p&gt;func main() {
      c1 := sha256.Sum256([]byte(“x”))
      c2 := sha256.Sum256([]byte(“X”))
      fmt.Printf(“%x\n%x\n%t\n%T\n”, c1, c2, c1 == c2, c1)
      // Output:                  &lt;br /&gt;
      //2d711642b726b04401627ca9fbac32f5c8530fb1903cc4db02258717921a4881
      // 4b68ab3847feda7d6c62c1fbcbeebfa35eab7351ed5e78f4ddadea5df64b8015
      // false
      // [32]uint8
  }
  ```&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;Go语言对待数组的方式和其它很多编程语言不同，其它编程语言可能会隐式地将数组作为引用或指针对象传入被调用的函数。
        &lt;blockquote&gt;
          &lt;p&gt;因为函数对待参数是值传递，需要复制参数变量，有些变成语言回见数据组隐式的转换为引用，以减少复制大型参数造成的额外开销。&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;虽然通过指针来传递数组参数是高效的，而且也允许在函数内部修改数组的值，但是数组依然是僵化的类型，因为数组的类型包含了僵化的长度信息。由于这些原因，除了像SHA256这类需要处理特定大小数组的特例外，数组依然很少用作函数参数；相反，我们一般使用slice来替代数组。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;slice：底层是用数组实现的，支持动态的扩容
    &lt;ul&gt;
      &lt;li&gt;组成
        &lt;ul&gt;
          &lt;li&gt;指针：指针指向第一个slice元素对应的底层数组元素的地址，要注意的是slice的第一个元素并不一定就是数组的第一个元素&lt;/li&gt;
          &lt;li&gt;长度：长度对应slice中元素的数目，长度不能超过容量&lt;/li&gt;
          &lt;li&gt;容量：容量一般是从slice的开始位置到底层数据的结尾位置。内置的len和cap函数分别返回slice的长度和容量。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;多个slice之间可以共享底层的数据，并且引用的数组部分区间可能重叠。图4.1显示了表示一年中每个月份名字的字符串数组，还有重叠引用了该数组的两个slice。
 &lt;img src=&quot;/images/10.png&quot; alt=&quot;9ca9eaf81a29acc6f76294e5cf97a179.png&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;因为slice值包含指向第一个slice元素的指针，因此向函数传递slice将允许在函数内部修改底层数组的元素。换句话说，复制一个slice只是对底层的数组创建了一个新的slice别名。下面的reverse函数在原内存空间将[]int类型的slice反转，而且它可以用于任意长度的slice。
 ```
 func reverse(s []int) {
  for i, j := 0, len(s)-1; i &amp;lt; j; i, j = i+1, j-1 {
      s[i], s[j] = s[j], s[i]
  }
 }&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;a := […]int{0, 1, 2, 3, 4, 5}
 reverse(a[:])
 fmt.Println(a) // “[5 4 3 2 1 0]”
 ```&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;slice底层是数组但并不能像数组一样比较。
        &lt;ul&gt;
          &lt;li&gt;一个原因slice的元素是间接引用的，一个slice甚至可以包含自身&lt;/li&gt;
          &lt;li&gt;第二个原因，因为slice的元素是间接引用的，一个固定的slice值(译注：指slice本身的值，不是元素的值)在不同的时刻可能包含不同的元素，因为底层数组的元素可能会被修改。slice扩容是地址也会发生改变。鉴于安全考虑直接禁止slice之间的比较操作，简化复杂度。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;判断空slice
        &lt;ul&gt;
          &lt;li&gt;如果你需要测试一个slice是否是空的，使用len(s) == 0来判断，而不应该用s == nil来判断。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;结构体：相当于类
    &lt;ul&gt;
      &lt;li&gt;一个命名为S的结构体类型将不能再包含S类型的成员：因为一个聚合的值不能包含它自身。（该限制同样适应于数组。）但是S类型的结构体可以包含*S指针类型的成员，这可以让我们创建递归的数据结构，比如链表和树结构等。&lt;/li&gt;
      &lt;li&gt;Go语言有一个特性让我们只声明一个成员对应的数据类型而不指名成员的名字；这类成员就叫匿名成员。匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针。下面的代码中，Circle和Wheel各自都有一个匿名成员。我们可以说Point类型被嵌入到了Circle结构体，同时Circle类型被嵌入到了Wheel结构体。
  ```
  type Point struct {
  X, Y int
  }&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;type Circle struct {
      Center Point
      Radius int
  }&lt;/p&gt;

    &lt;p&gt;type Wheel struct {
      Circle Circle
      Spokes int
  }&lt;/p&gt;

    &lt;p&gt;var w Wheel
  w.X = 8            // equivalent to w.Circle.Point.X = 8
  w.Y = 8            // equivalent to w.Circle.Point.Y = 8
  w.Radius = 5       // equivalent to w.Circle.Radius = 5
  w.Spokes = 20
  ```&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;在右边的注释中给出的显式形式访问这些叶子成员的语法依然有效，因此匿名成员并不是真的无法访问了。其中匿名成员Circle和Point都有自己的名字——就是命名的类型名字——但是这些名字在点操作符中是可选的。我们在访问子成员的时候可以忽略任何匿名成员部分。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;map
    &lt;ul&gt;
      &lt;li&gt;map 底层也是固定数组，通过哈希表映射&lt;/li&gt;
      &lt;li&gt;map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作，禁止对map元素取址的原因是map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效。&lt;/li&gt;
      &lt;li&gt;Map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。这是故意的，每次都使用随机的遍历顺序可以强制要求程序不会依赖具体的哈希函数实现。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;类型就是数据结构，写代码先定义数据结构，数据结构决定了代码的走向决定了用什么算法。学海无涯苦作舟，千帆过尽还复来。继续努力吧。&lt;/p&gt;</content><author><name></name></author><summary type="html">Go数据类型有如下类型。 基础类型 复合类型 引用类型 接口类型 类型内容很多只能慢慢学习，今天学习复合类型。</summary></entry><entry><title type="html">Go学习笔记2</title><link href="/go/2019/04/17/Go-2.html" rel="alternate" type="text/html" title="Go学习笔记2" /><published>2019-04-17T00:00:00+08:00</published><updated>2019-04-17T00:00:00+08:00</updated><id>/go/2019/04/17/Go-2</id><content type="html" xml:base="/go/2019/04/17/Go-2.html">&lt;p&gt;Go数据类型有如下类型。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;基础类型&lt;/li&gt;
  &lt;li&gt;符合类型&lt;/li&gt;
  &lt;li&gt;引用类型&lt;/li&gt;
  &lt;li&gt;接口类型
类型内容很多只能慢慢学习，今天学习基础类型。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;基础类型&quot;&gt;基础类型&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;数字
    &lt;ul&gt;
      &lt;li&gt;有符号无符号&lt;/li&gt;
      &lt;li&gt;Unicode字符rune类型是和int32等价的类型&lt;/li&gt;
      &lt;li&gt;byte也是uint8类型的等价类型&lt;/li&gt;
      &lt;li&gt;计算溢出 高位截断
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; var u uint8 = 255
 fmt.Println(u, u+1, u*u) // &quot;255 0 1&quot;
 var i int8 = 127
 fmt.Println(i, i+1, i*i) // &quot;127 -128 1&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;位运算
  ```
 var x uint8 = 1«1 | 1«5var y uint8 = 1«1 | 1«2&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;fmt.Printf(“%08b\n”, x) // “00100010”, the set {1, 5}
 fmt.Printf(“%08b\n”, y) // “00000110”, the set {1, 2}&lt;/p&gt;

    &lt;p&gt;fmt.Printf(“%08b\n”, x&amp;amp;y)  // “00000010”, the intersection {1}
 fmt.Printf(“%08b\n”, x|y)  // “00100110”, the union {1, 2, 5}
 fmt.Printf(“%08b\n”, x^y)  // “00100100”, the symmetric difference {2, 5}
 fmt.Printf(“%08b\n”, x&amp;amp;^y) // “00100000”, the difference {5}&lt;/p&gt;

    &lt;p&gt;for i := uint(0); i &amp;lt; 8; i++ {
     if x&amp;amp;(1«i) != 0 { // membership test
         fmt.Println(i) // “1”, “5”
     }
 }&lt;/p&gt;

    &lt;p&gt;fmt.Printf(“%08b\n”, x«1) // “01000100”, the set {2, 6}
 fmt.Printf(“%08b\n”, x»1) // “00010001”, the set {0, 4}
  ```&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;浮点型
        &lt;blockquote&gt;
          &lt;p&gt;一个float32类型的浮点数可以提供大约6个十进制数的精度，而float64则可以提供约15个十进制数的精度；通常应该优先使用float64类型，因为float32类型的累计计算误差很容易扩散，并且float32能精确表示的正整数并不是很大（译注：因为float32的有效bit位只有23个，其它的bit位用于指数和符号；当整数大于23bit能表达的范围时，float32的表示将出现误差）&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;字符串:一个字符串是一个不可改变的字节序列
    &lt;ul&gt;
      &lt;li&gt;不变性意味如果两个字符串共享相同的底层数据的话也是安全的，这使得复制任何长度的字符串代价是低廉的&lt;/li&gt;
      &lt;li&gt;编码：编码是一个基础，但是很复杂的东西，很多原理都跟编码有关。
        &lt;ul&gt;
          &lt;li&gt;ASC II：是最初的编码定义，用一个字节来表示 0-127 表示英文和符号&lt;/li&gt;
          &lt;li&gt;Unicode：随着计算机的广泛使用，其他国家的语言和文字需要展示，一个字节不够用了所以用4个字节来保存，诞生了unicode编码，至今unicode已经120000的字符了&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;http://unicode.org &quot;&gt;Unicode官方&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;UTF-8:由于unicode 需要4个字节，有字符实际用不到这么多存储为，但是占用了这么的空间很浪费，所以UTF-8可变长字编码格式产生了，它位不同的长度的Uicode编码使用不用的表示方式。如下
            &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 0xxxxxxx                                                   runes 0-127    (ASCII)
 110xxxxx 10xxxxxx                                  128-2047       (values &amp;lt;128 unused)
 1110xxxx 10xxxxxx 10xxxxxx                   2048-65535     (values &amp;lt;2048 unused)
 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx   65536-0x10ffff (other values unused)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;Go语言的range循环在处理字符串的时候，会自动隐式解码UTF8字符串&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;标准库中四个重要的库
        &lt;ul&gt;
          &lt;li&gt;btyes:btye的查找，替换，比较，截取，拆分，合并等功能
            &lt;ul&gt;
              &lt;li&gt;因为字符串是只读的，因此逐步构建字符串会导致很多分配和复制&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;strings：字符串btye的查找，替换，比较，截取，拆分，合并等功能&lt;/li&gt;
          &lt;li&gt;strconv：字符串转化&lt;/li&gt;
          &lt;li&gt;unicode：给字符分类&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;布尔：没有什么特别注意的，就是要讲数字当bool值需要做一个函数转换
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; func itob(i int) bool { return i != 0 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;常量：常量表达式的值在编译期计算，而不是在运行期。
    &lt;ul&gt;
      &lt;li&gt;iota 可以批量生成常量
 ```angular2html
 type Weekday int&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;const (
     Sunday Weekday = iota
     Monday
     Tuesday
     Wednesday
     Thursday
     Friday
     Saturday
 )
 //复杂例子
 const (
     _ = 1 « (10 * iota)
     KiB // 1024
     MiB // 1048576
     GiB // 1073741824
     TiB // 1099511627776             (exceeds 1 « 32)
     PiB // 1125899906842624
     EiB // 1152921504606846976
     ZiB // 1180591620717411303424    (exceeds 1 « 64)
     YiB // 1208925819614629174706176
 )
 ```&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;无类型常量：我个人理解无类型常量有点像php不定义变量类型，系统自动识别，后面学习到接口时有重要的作用。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;虽然每种语言都有这些类型，但是每种语言在细节处理上有相似也有不同，这些相似和不同就体现出了不同人的思考方式，总之代码是死的，思维是活的。多思考多实践，形成自己的思维体系更重要。&lt;/p&gt;</content><author><name></name></author><summary type="html">Go数据类型有如下类型。 基础类型 符合类型 引用类型 接口类型 类型内容很多只能慢慢学习，今天学习基础类型。</summary></entry><entry><title type="html">Go直播实践</title><link href="/go/live/2019/04/16/Go_live-1.html" rel="alternate" type="text/html" title="Go直播实践" /><published>2019-04-16T00:00:00+08:00</published><updated>2019-04-16T00:00:00+08:00</updated><id>/go/live/2019/04/16/Go_live-1</id><content type="html" xml:base="/go/live/2019/04/16/Go_live-1.html">&lt;p&gt;视频直播是近些年特别火的技术栈，一直想学习如何实现视频直播。初期也了解了一些协议相关的知识，苦于都是c++相关学习起来比较难以理解，学习了Go语言之后突然想找一找是否有Go语言实现的直播服务，惊奇的发现，Livego这个开源直播服务端，自此展开了Go直播实践之路，由于工作繁重，只能抽时间搞，耽误了好几天的更新，话不多说直入正题。&lt;/p&gt;

&lt;h2 id=&quot;服务端&quot;&gt;服务端&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/gwuhaolin/livego&quot;&gt;livego&lt;/a&gt; 精挑细选 简单可靠 便于二次开发&lt;/li&gt;
  &lt;li&gt;livego的相关参数可以看源码或者help非常直观&lt;/li&gt;
  &lt;li&gt;对于服务端不是很难编译到运行不到2分钟，主要是注意推流时，格式的选取&lt;/li&gt;
  &lt;li&gt;上行推流：使用ffmpeg上行视频流
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ffmpeg -re -i test.mp4 -c copy -f flv 
rtmp://192.168.112.20:1935/live/movie
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;总结：服务端是较为简单的没有任何难点&lt;/p&gt;
    &lt;h2 id=&quot;客户端&quot;&gt;客户端&lt;/h2&gt;
    &lt;p&gt;对于一个服务端来说，客户端编码是最让人头疼的。我选取的h5客户端流解析工具&lt;a href=&quot;https://github.com/bilibili/flv.js&quot;&gt;flv.js&lt;/a&gt;&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;p&gt;题外话
对于前端工具真的很烦，npm安装可把我搞惨了，我是虚拟机+共享目录，我在虚拟机中npm install 它居然不认识我的共享目录，总是在rename的时候，提示权限有误无法操作，致使我在构建flv.js客户端环境上花了大量的时间，把一个两天搞定的事，一周才搞定。我是通过在虚拟机其他目录进行install在将安装好的文件拷贝到共享目录，最终还是搞定了。还有吐槽一下哔哩哔哩这么一个厉害的前端同学才给5000的工资真的说不过去。给做开源的各位大大点赞。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;安装环境
    &lt;ul&gt;
      &lt;li&gt;克隆github&lt;/li&gt;
      &lt;li&gt;npm install&lt;/li&gt;
      &lt;li&gt;npm install -g gulp&lt;/li&gt;
      &lt;li&gt;gulp release
不知道这些组件是干什么用的，就按就得了哈哈
        &lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;nginx 配置demo&lt;/li&gt;
  &lt;li&gt;编译开启服务
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  go build
  ./livego
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;推流
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ffmpeg -re -i test.mp4 -c copy -f flv rtmp://192.168.112.20:1935/live/movie
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;demo中配置源&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/9.png&quot; alt=&quot;628bf39eeb1d51e6e0106e4bd5b6d08a.png&quot; /&gt;
 ## 总结&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;GO真的是一个好语言，一个好的粘合剂&lt;/li&gt;
  &lt;li&gt;前端工具真麻烦，像php的composer多好，还是前端的变化太快，跟不上潮流，还是喜欢一些底层一点的不那么麻烦。&lt;/li&gt;
  &lt;li&gt;直播
    &lt;ul&gt;
      &lt;li&gt;协议的实现&lt;/li&gt;
      &lt;li&gt;流的上行&lt;/li&gt;
      &lt;li&gt;流的下行&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;还有一些其他的可以学习的内容比如
    &lt;ul&gt;
      &lt;li&gt;视频的格式&lt;/li&gt;
      &lt;li&gt;流的缓存&lt;/li&gt;
      &lt;li&gt;压力测试&lt;/li&gt;
      &lt;li&gt;负载均衡&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;等等视频直播是一个大的技术栈不是像我这种简单的玩一下的，如果想深入做还是需要一定的功力和精力。只是供大家学习和体验。&lt;/p&gt;</content><author><name></name></author><summary type="html">视频直播是近些年特别火的技术栈，一直想学习如何实现视频直播。初期也了解了一些协议相关的知识，苦于都是c++相关学习起来比较难以理解，学习了Go语言之后突然想找一找是否有Go语言实现的直播服务，惊奇的发现，Livego这个开源直播服务端，自此展开了Go直播实践之路，由于工作繁重，只能抽时间搞，耽误了好几天的更新，话不多说直入正题。</summary></entry><entry><title type="html">Go学习笔记1</title><link href="/go/2019/04/11/Go-1.html" rel="alternate" type="text/html" title="Go学习笔记1" /><published>2019-04-11T00:00:00+08:00</published><updated>2019-04-11T00:00:00+08:00</updated><id>/go/2019/04/11/Go-1</id><content type="html" xml:base="/go/2019/04/11/Go-1.html">&lt;p&gt;最近写了很多了Go代码，但是对于Go的深入内容知之甚少，为了达到知其然，并知其所以然的想法。开始了学习之旅，首选学习素材&lt;a href=&quot;https://books.studygolang.com/gopl-zh/index.html&quot;&gt;GO圣经&lt;/a&gt;。把自己觉得有用的都记下来，以便以后拿来温习。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Go 没有的特性
    &lt;ul&gt;
      &lt;li&gt;它没有隐式的数值转换&lt;/li&gt;
      &lt;li&gt;没有构造函数和析构函数&lt;/li&gt;
      &lt;li&gt;没有运算符重载&lt;/li&gt;
      &lt;li&gt;没有默认参数&lt;/li&gt;
      &lt;li&gt;没有继承&lt;/li&gt;
      &lt;li&gt;没有泛型&lt;/li&gt;
      &lt;li&gt;没有异常&lt;/li&gt;
      &lt;li&gt;没有宏&lt;/li&gt;
      &lt;li&gt;没有函数修饰&lt;/li&gt;
      &lt;li&gt;更没有线程局部存储&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;声明的类型
    &lt;ul&gt;
      &lt;li&gt;var：变量&lt;/li&gt;
      &lt;li&gt;type：类型&lt;/li&gt;
      &lt;li&gt;const：常量&lt;/li&gt;
      &lt;li&gt;func：函数&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;各种类型对应的零值
    &lt;ul&gt;
      &lt;li&gt;数值对应的零值是0&lt;/li&gt;
      &lt;li&gt;布尔值对应零值是false&lt;/li&gt;
      &lt;li&gt;字符串对应零值是空字符串&lt;/li&gt;
      &lt;li&gt;接口或引用类型（包括slice、指针、map、chan和函数）对应nil&lt;/li&gt;
      &lt;li&gt;数组或者结构体对应内部每种类型对应的零值&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;变量的声明周期
    &lt;ul&gt;
      &lt;li&gt;变量的生命周期指的是在程序运行期间变量有效存在的时间间隔。对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，局部变量的声明周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。&lt;/li&gt;
      &lt;li&gt;垃圾回收
        &lt;ul&gt;
          &lt;li&gt;基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var global *int
func f() {
    var x int
    x = 1
    global = &amp;amp;x
}
func g() {
    y := new(int)
    *y = 1
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;f函数里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然它是在函数内部定义的；用Go语言的术语说，这个x局部变量从函数f中逃逸了。相反，当g函数返回时，变量&lt;em&gt;y将是不可达的，也就是说可以马上被回收的。因此，&lt;/em&gt;y并没有从函数g中逃逸，编译器可以选择在栈上分配*y的存储空间（也可以选择在堆上分配，然后由Go语言的GC回收这个变量的内存空间），虽然这里用的是new方式。其实在任何时候，你并不需为了编写正确的代码而要考虑变量的逃逸行为，要记住的是，逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;赋值
    &lt;ul&gt;
      &lt;li&gt;赋值语句是显式的赋值形式，但是程序中还有很多地方会发生隐式的赋值行为：函数调用会隐式地将调用参数的值赋值给函数的参数变量，一个返回语句会隐式地将返回操作的值赋值给结果变量，一个复合类型的字面量也会产生赋值行为。例如下面的语句：
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;medals := []string{&quot;gold&quot;, &quot;silver&quot;, &quot;bronze&quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;作用域
    &lt;ul&gt;
      &lt;li&gt;不要将作用域和生命周期混为一谈。声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时的属性。一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个运行时的概念。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;作用域类型
    &lt;ul&gt;
      &lt;li&gt;词法块：花括弧所包含的一系列语句&lt;/li&gt;
      &lt;li&gt;词法块可以深度嵌套，变量的生命周期在此法块中。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">最近写了很多了Go代码，但是对于Go的深入内容知之甚少，为了达到知其然，并知其所以然的想法。开始了学习之旅，首选学习素材GO圣经。把自己觉得有用的都记下来，以便以后拿来温习。</summary></entry></feed>