<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2019-08-27T20:33:39+08:00</updated><id>/feed.xml</id><title type="html">一叶障目</title><subtitle>学无止境</subtitle><entry><title type="html">filebeat折腾</title><link href="/filebeats/2019/08/26/Blog-filebeat.html" rel="alternate" type="text/html" title="filebeat折腾" /><published>2019-08-26T00:00:00+08:00</published><updated>2019-08-26T00:00:00+08:00</updated><id>/filebeats/2019/08/26/Blog-filebeat</id><content type="html" xml:base="/filebeats/2019/08/26/Blog-filebeat.html">&lt;p&gt;最近一段时间都在整理知识体系，还没整理完备，然后就被拉着做新的消息队列的接入，原来使用kafka，切到了rabbitmq。切换还算顺利，同时又有同事想做日志系统的想法。我突然灵光一线，为什么不能filebeat + 消息队列实现集中式日志管理呢？&lt;/p&gt;
&lt;h2 id=&quot;调研&quot;&gt;调研&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;kafka 适合日志型 队列服务，采取订阅式的消息拉取&lt;/li&gt;
  &lt;li&gt;rabbitmq 功能能丰富，适合业务逻辑使用，不建议用作日志收集&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;功能&lt;/th&gt;
      &lt;th&gt;kafka&lt;/th&gt;
      &lt;th&gt;Rabbitmq&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;优先级队列&lt;/td&gt;
      &lt;td&gt;不支持&lt;/td&gt;
      &lt;td&gt;支持，建议优先级大小设置在0-10之间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;延迟队列&lt;/td&gt;
      &lt;td&gt;不支持&lt;/td&gt;
      &lt;td&gt;支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;死信队列&lt;/td&gt;
      &lt;td&gt;不支持&lt;/td&gt;
      &lt;td&gt;支持（死信队列，是指一些无法正常消费的消息，为了不影响正常的队列运行，将这些消息添加到死信队列，通过处理死信队列处理异常消息）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;重试队列&lt;/td&gt;
      &lt;td&gt;不支持&lt;/td&gt;
      &lt;td&gt;不支持，RabbitMQ中可以参考延迟队列实现重试队列，二次封装比较简单。如果要在Kafka中实现延迟队列功能，相对比较复杂&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;消费模式&lt;/td&gt;
      &lt;td&gt;拉模式（订阅）&lt;/td&gt;
      &lt;td&gt;推模式+拉模式广播消费支持。Kafka对于广播消费的支持相对而言更加正统支持，但力度较Kafka弱消息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;回溯&lt;/td&gt;
      &lt;td&gt;支持。Kafka支持按照Offset和timestamp两种维度进行消息回溯不支持。&lt;/td&gt;
      &lt;td&gt;RabbitMQ中消息一旦被确认消费就会被标记删除&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;消息堆积&lt;/td&gt;
      &lt;td&gt;支持&lt;/td&gt;
      &lt;td&gt;支持。一般情况下，内存堆积达到特定阀值时会影响其性能，但这不是绝对的。如果考虑吞吐因素，Kafka的堆积效率比RabbitMQ总体上要高很多&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;持久化&lt;/td&gt;
      &lt;td&gt;支持&lt;/td&gt;
      &lt;td&gt;支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;消息追踪&lt;/td&gt;
      &lt;td&gt;不支持。消息追踪可以通过外部系统来支持，但是支持力度没有内置细腻支持。&lt;/td&gt;
      &lt;td&gt;RabbitMQ中可以采用Firehose或者rabbitmq_tracing插件实现。不过开启rabbitmq_tracing插件会大幅影响性能，不建议生产环境开启，反倒是可以使用Firehose与外部链路系统结合提供高细腻度的消息追踪支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;消息过滤&lt;/td&gt;
      &lt;td&gt;客户端级别支持&lt;/td&gt;
      &lt;td&gt;不支持，但是二次封装一下也非常简单&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;多租户&lt;/td&gt;
      &lt;td&gt;不支持&lt;/td&gt;
      &lt;td&gt;支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;多协议&lt;/td&gt;
      &lt;td&gt;支持只支持定义协议，目前几个主流版本见存在兼容性问题&lt;/td&gt;
      &lt;td&gt;RabbitMQ本身就是AMQP协议的实现，同时支持MQTT、STOMP等协议。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;跨语言&lt;/td&gt;
      &lt;td&gt;支持采用Scala和java编写，支持多种语言的客户端&lt;/td&gt;
      &lt;td&gt;采用Erlang编写，支持多种语言的客户端&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;流量控制&lt;/td&gt;
      &lt;td&gt;支持client和user级别，通过主动设置可将流控作用域生产者或消费者&lt;/td&gt;
      &lt;td&gt;RabbitMQ的流控基于Credit-Based的算法，是内部被动触发的保护机制，作用于生产者层面&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;消息顺序性&lt;/td&gt;
      &lt;td&gt;支持单分区级别的顺序性&lt;/td&gt;
      &lt;td&gt;顺序的条件比较苛刻，需要单线程发送，单线程消费并且不采用延迟队列，优先队列等一些高级功能，从某种意义上来说不算支持顺序性&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;安全支持&lt;/td&gt;
      &lt;td&gt;（TLS/SSL、SASL）身份认证和（读写）权限控制&lt;/td&gt;
      &lt;td&gt;与Kafka相似&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;幂等性&lt;/td&gt;
      &lt;td&gt;支持单个生产者单分区单回话的幂等性（单次或多次执行后是一样的）&lt;/td&gt;
      &lt;td&gt;不支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;事务性消息&lt;/td&gt;
      &lt;td&gt;支持&lt;/td&gt;
      &lt;td&gt;支持&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;filebeats 支持kafka 不支持 rabbitmq
    &lt;h2 id=&quot;折腾filebeats&quot;&gt;折腾filebeats&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;Go 的kafka 已经折腾过了，为了给自己练练手准备让filebeats支持rabbitmq 。&lt;/li&gt;
  &lt;li&gt;找到了https://github.com/sidleal/mqttout&lt;/li&gt;
  &lt;li&gt;自己尝试使用发现新版filebeat的接口有些改变，而且他用的链接rabbitmq的底层库也比较老，唯有自己动手&lt;/li&gt;
  &lt;li&gt;在原有的基础上做了改动https://github.com/xiangdong1987/mqttout感觉能用，用的到大家随便用。
    &lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
    &lt;p&gt;学习的过程就是想到就去实践，不懂得就去学习，最后达成目标，估计这就是一个大龄程序员还能继续码代码的动力了。继续整理知识体系去了。留下一个思路，用kafka+filebeats实现模调系统以及日志系统。或者听听各位大神的意见。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">最近一段时间都在整理知识体系，还没整理完备，然后就被拉着做新的消息队列的接入，原来使用kafka，切到了rabbitmq。切换还算顺利，同时又有同事想做日志系统的想法。我突然灵光一线，为什么不能filebeat + 消息队列实现集中式日志管理呢？ 调研 kafka 适合日志型 队列服务，采取订阅式的消息拉取 rabbitmq 功能能丰富，适合业务逻辑使用，不建议用作日志收集</summary></entry><entry><title type="html">记一次面试经历</title><link href="/blog/2019/08/13/Blog-interview.html" rel="alternate" type="text/html" title="记一次面试经历" /><published>2019-08-13T00:00:00+08:00</published><updated>2019-08-13T00:00:00+08:00</updated><id>/blog/2019/08/13/Blog-interview</id><content type="html" xml:base="/blog/2019/08/13/Blog-interview.html">&lt;p&gt;现在的公司待久了，没什么晋升机会，突然想跳槽了，正好也检验一下自己的水平位置。本来内心是毫无波澜的，谁知道面试后内心波涛汹涌。今天来谈谈感受。&lt;/p&gt;
&lt;h2 id=&quot;行情&quot;&gt;行情&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;大厂卡学历&lt;/li&gt;
  &lt;li&gt;小公司薪资降低&lt;/li&gt;
  &lt;li&gt;能力要求高
    &lt;h2 id=&quot;投简历&quot;&gt;投简历&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;只投了一些心仪的公司，php转go没太报希望&lt;/li&gt;
  &lt;li&gt;针对jd准备了很多相关知识 （结果完全没用到）
    &lt;ul&gt;
      &lt;li&gt;比如分布式系统&lt;/li&gt;
      &lt;li&gt;一致性哈希&lt;/li&gt;
      &lt;li&gt;cassandra&lt;/li&gt;
      &lt;li&gt;go 基础知识&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;面试公司
    &lt;ul&gt;
      &lt;li&gt;一家电商&lt;/li&gt;
      &lt;li&gt;一家哈喽单车
        &lt;h2 id=&quot;面试难度&quot;&gt;面试难度&lt;/h2&gt;
        &lt;p&gt;总结：常规要会，深度要深，广度要广&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;常规：
    &lt;ul&gt;
      &lt;li&gt;mysql&lt;/li&gt;
      &lt;li&gt;redis&lt;/li&gt;
      &lt;li&gt;tcp协议&lt;/li&gt;
      &lt;li&gt;linux系统&lt;/li&gt;
      &lt;li&gt;逻辑思维&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;深度
    &lt;ul&gt;
      &lt;li&gt;数据结构&lt;/li&gt;
      &lt;li&gt;算法实现&lt;/li&gt;
      &lt;li&gt;语言特性实现&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;广度
    &lt;ul&gt;
      &lt;li&gt;语言特性&lt;/li&gt;
      &lt;li&gt;相关定义&lt;/li&gt;
      &lt;li&gt;组件了解
        &lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
        &lt;p&gt;经过短暂的两次面试发现，面试是对自己一次真实情况的合理评估，在没有准备充分的情况千万不要乱尝试，除非打算用面海战术，面海战术可以快速提升，但是有可能让你错过心仪的公司。准备系统的整理一下自己的知识体系，觉得知识都有就是不成体系，无法内化。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">现在的公司待久了，没什么晋升机会，突然想跳槽了，正好也检验一下自己的水平位置。本来内心是毫无波澜的，谁知道面试后内心波涛汹涌。今天来谈谈感受。 行情 大厂卡学历 小公司薪资降低 能力要求高 投简历 只投了一些心仪的公司，php转go没太报希望 针对jd准备了很多相关知识 （结果完全没用到） 比如分布式系统 一致性哈希 cassandra go 基础知识 面试公司 一家电商 一家哈喽单车 面试难度 总结：常规要会，深度要深，广度要广 常规： mysql redis tcp协议 linux系统 逻辑思维 深度 数据结构 算法实现 语言特性实现 广度 语言特性 相关定义 组件了解 总结 经过短暂的两次面试发现，面试是对自己一次真实情况的合理评估，在没有准备充分的情况千万不要乱尝试，除非打算用面海战术，面海战术可以快速提升，但是有可能让你错过心仪的公司。准备系统的整理一下自己的知识体系，觉得知识都有就是不成体系，无法内化。</summary></entry><entry><title type="html">折腾kafka</title><link href="/go/2019/08/01/Go-kafka.html" rel="alternate" type="text/html" title="折腾kafka" /><published>2019-08-01T00:00:00+08:00</published><updated>2019-08-01T00:00:00+08:00</updated><id>/go/2019/08/01/Go-kafka</id><content type="html" xml:base="/go/2019/08/01/Go-kafka.html">&lt;p&gt;kafka 实践学习，对于一个java大生态的工具，还是需要学习和了解的，毕竟java大佬这么多年了，值得学习的地方非常多。&lt;/p&gt;

&lt;h2 id=&quot;apache-kafka&quot;&gt;Apache Kafka&lt;/h2&gt;
&lt;p&gt;Apache Kafka是一个分布式发布 - 订阅消息系统和一个强大的队列，可以处理大量的数据，并使您能够将消息从一个端点传递到另一个端点。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;特点
    &lt;ul&gt;
      &lt;li&gt;分布系统&lt;/li&gt;
      &lt;li&gt;订阅消息&lt;/li&gt;
      &lt;li&gt;强大队列&lt;/li&gt;
      &lt;li&gt;数据落地到硬盘
        &lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;前置条件：需要zookeeper。&lt;/li&gt;
  &lt;li&gt;安装zookeeper
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.apache.org/dyn/closer.cgi/zookeeper/&quot;&gt;官方下载&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;接下即安装（java 生态就是好）&lt;/li&gt;
      &lt;li&gt;conf 下 sample 文件改成 zoo.cfg (默认单机模式)&lt;/li&gt;
      &lt;li&gt;zookeeper 常用命令&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      //开启 zookeeper
      bin/zkServer.sh start
      //使用客户端连接
      bin/zkCli.sh
      //远程连接
      bin/zkCli.sh -server ip:port
      //停止zookeeper
      bin/zkServer.sh stop
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;其他相关zookeeper不细讲用到在学习&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;安装kafaka
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.apache.org/dyn/closer.cgi?path=/kafka/2.3.0/kafka-2.3.0-src.tgz&quot;&gt;官方下载&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;接下即安装（java 生态就是好）&lt;/li&gt;
      &lt;li&gt;kafaka 常用命令&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      //开启kafaka
      bin/kafka-server-start.sh config/server.properties
      //创建Topic  
      bin/kafka-topics.sh --create --zookeeper 192.168.112.20:2181 --replication-factor 1 --partitions 1 --topic test
      //Topic展示
      bin/kafka-topics.sh --list --zookeeper 192.168.112.20:2181
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;遇到的问题：下载的是kafka的源码包，执行报错 
classpath is empty. please build the project first e.g. by running ‘gradlew jarall’ 应该下载二进制包
下载地址：&lt;a href=&quot;https://kafka.apache.org/downloads&quot;&gt;https://kafka.apache.org/downloads&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;## 使用Go实现生产消费&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;实现生产者&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;s2&quot;&gt;&quot;bufio&quot;&lt;/span&gt;
	&lt;span class=&quot;s2&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
	&lt;span class=&quot;s2&quot;&gt;&quot;github.com/Shopify/sarama&quot;&lt;/span&gt;
	&lt;span class=&quot;s2&quot;&gt;&quot;os&quot;&lt;/span&gt;
	&lt;span class=&quot;s2&quot;&gt;&quot;strings&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sarama&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewConfig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Producer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Successes&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Producer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RequiredAcks&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sarama&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WaitForAll&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Producer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Partitioner&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sarama&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewRandomPartitioner&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;初始化生产者&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;producer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sarama&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewSyncProducer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;192.168.112.20:9092&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;!= nil {
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;producer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    
    &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sarama&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ProducerMessage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Topic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;s2&quot;&gt;&quot;testGo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Partition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(-&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;       &lt;span class=&quot;n&quot;&gt;sarama&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;StringEncoder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;string&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;生产消息&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;inputReader&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bufio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewReader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Stdin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inputReader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReadString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;!= nil {
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strings&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Replace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sarama&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ByteEncoder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;发送消息&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;paritition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;producer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SendMessage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;!= nil {
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Send Message Fail&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;输出结果&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Partion = %d, offset = %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;paritition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;实现消费者&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;s2&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
	&lt;span class=&quot;s2&quot;&gt;&quot;github.com/Shopify/sarama&quot;&lt;/span&gt;
	&lt;span class=&quot;s2&quot;&gt;&quot;sync&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;协成锁&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;等待所有协成执行完毕退出&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;WaitGroup&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;消费者初始化&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sarama&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NewConsumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;192.168.112.20:9092&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;!= nil {
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;partitionList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Partitions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;testGo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;!= nil {
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;partition&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;partitionList&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;pc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ConsumePartition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;testGo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;partition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sarama&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OffsetNewest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;!= nil {
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AsyncClose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;上锁&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sarama&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PartitionConsumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;解锁&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Messages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;接受消息&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Partition:%d, Offset:%d, Key:%s, Value:%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Partition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;等待全部解锁&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;wg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;遇到问题 github.com/Shopify/sarama 包在windows 环境下需要gcc，懒得搞直接虚拟机。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;利用go + kafka 实现生产者消费模型非常简单和快速，在日常业务上使用消息队列可以考虑kafka+go快速迭代，后续应用上采坑在来分享。&lt;/p&gt;</content><author><name></name></author><summary type="html">kafka 实践学习，对于一个java大生态的工具，还是需要学习和了解的，毕竟java大佬这么多年了，值得学习的地方非常多。</summary></entry><entry><title type="html">easyGin 开源心得</title><link href="/go/2019/07/30/Go-easyGin.html" rel="alternate" type="text/html" title="easyGin 开源心得" /><published>2019-07-30T00:00:00+08:00</published><updated>2019-07-30T00:00:00+08:00</updated><id>/go/2019/07/30/Go-easyGin</id><content type="html" xml:base="/go/2019/07/30/Go-easyGin.html">&lt;p&gt;自上次在v2ex发了一篇，关于我对从php转go的心得，发了自己的开源(https://github.com/xiangdong1987/easyGin)[https://github.com/xiangdong1987/easyGin]感觉反响挺大，被骂的挺惨的，不过我也从中学习了很多东西。今天来总结一下，顺便看看大家还有没有新的意见和建议。&lt;/p&gt;

&lt;h2 id=&quot;go-mod&quot;&gt;Go mod&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;官方支持的包管理工具自，从golang 1.11 新加的特性&lt;/li&gt;
  &lt;li&gt;好处：go run 时自动引入依赖包  存储在 $GOPATH/src/pkg 目录&lt;/li&gt;
  &lt;li&gt;使用方式：
    &lt;ul&gt;
      &lt;li&gt;更新到新版go&lt;/li&gt;
      &lt;li&gt;设置如下配置&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  //开启mod
  export GO111MODULE=on
    
  //设置代理
  export GOPROXY=https://gocenter.io
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;只能说谁用谁知道&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;go-template&quot;&gt;Go template&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;提供了模板渲染 方便灵活&lt;/li&gt;
  &lt;li&gt;使用方式&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type CurdTemplate struct {
	LowerName  string
}
routerTemplate=`lower:`
t := template.New(&quot;router&quot;)
curdStrut := CurdTemplate{strings.ToLower(&quot;Person&quot;)}
//解析内容到模板
t, err = t.Parse(routerTemplate)
if err != nil {
    log.Fatal(&quot;Parse:&quot;, err)
}
//将数据用到模板中
buf := new(bytes.Buffer)
if err = t.Execute(buf, curdStrut); err != nil {
    log.Fatal(&quot;Execute:&quot;, err)   
} else {
    result = buf.String()
}
fmt.Println(result)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;go-convey代码测试及代码覆盖&quot;&gt;Go convey代码测试及代码覆盖&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;这个库提供了代码测试的重新封装，使用友好，还可以提供页面展示代码覆盖率自动测试功能。程序规范化典范（感觉又要挨骂了）&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TestInitRouter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;testing&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Convey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;model 路由&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
		&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InitDB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;company&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
		&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InitRouter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Person&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;D:/data/go/src/easyGin/router/&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
		&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Convey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;model 生成&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
			&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;So&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ShouldEqual&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;x&quot;&gt; &lt;/span&gt;&lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
		&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;x&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;性能测试&quot;&gt;性能测试&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;使用ab进行测试，毕竟我们是api接口&lt;/li&gt;
  &lt;li&gt;测试环境：
    &lt;ul&gt;
      &lt;li&gt;虚拟机 2G 内存 单核&lt;/li&gt;
      &lt;li&gt;数据库 测试环境单机&lt;/li&gt;
      &lt;li&gt;量100 并发 10000 请求&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;测试结果：
&lt;img src=&quot;https://github.com/xiangdong1987/easyGin/raw/master/static/ab.png&quot; alt=&quot;测试结果&quot; /&gt;
    &lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
    &lt;p&gt;我觉得大家的批评都挺好的，指出了我的不足，然后让我不断进步，感觉这就是开源的乐趣吧！希望各位大神多给点意见，不吝赐教。还有最好有人能提pr大家一起维护，做一个有用的工具而不是玩具。在这在募集一波大神。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">自上次在v2ex发了一篇，关于我对从php转go的心得，发了自己的开源(https://github.com/xiangdong1987/easyGin)[https://github.com/xiangdong1987/easyGin]感觉反响挺大，被骂的挺惨的，不过我也从中学习了很多东西。今天来总结一下，顺便看看大家还有没有新的意见和建议。</summary></entry><entry><title type="html">双色球预测到放弃</title><link href="/python/2019/07/08/python-guess_lottery.html" rel="alternate" type="text/html" title="双色球预测到放弃" /><published>2019-07-08T00:00:00+08:00</published><updated>2019-07-08T00:00:00+08:00</updated><id>/python/2019/07/08/python-guess_lottery</id><content type="html" xml:base="/python/2019/07/08/python-guess_lottery.html">&lt;h2 id=&quot;起因&quot;&gt;起因&lt;/h2&gt;
&lt;p&gt;我一直有个发财梦，就是靠技术能计算出双色球的走势，从而实现财富自由走向人生巅峰，这个梦一直魂牵梦绕着我，直到最新开始学大数据分析开始，我坚信只要有梦想早晚一天会破碎。&lt;/p&gt;
&lt;h2 id=&quot;过程&quot;&gt;过程&lt;/h2&gt;
&lt;p&gt;学习过程历时2周，从python语言基础到，大数据分析工具的使用。过程参考下面的github&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xiangdong1987/python_data_analysis&quot; title=&quot;https://github.com/xiangdong1987/python_data_analysis&quot;&gt;https://github.com/xiangdong1987/python_data_analysis&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;课程是根据极客时间的下面的课程&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://time.geekbang.org/column/intro/147&quot; title=&quot;数据分析实战&quot;&gt;数据分析实战45讲&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总体感受，老师讲的挺实战的，不过如果讲原理也太多太深的数学知识也很难消化，比如我自己也展开的看了看，不过太难了，还是需要的时候看吧&lt;/p&gt;

&lt;p&gt;对于大数据分析无外乎三个阶段&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数据获取与加载（80%的时间）&lt;/li&gt;
  &lt;li&gt;数据清洗与加工（15%的时间）&lt;/li&gt;
  &lt;li&gt;模型生成与预测（5%的时间）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用的数据算法包含如下几种（还有几种还没学完，想看关注github）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xiangdong1987/python_data_analysis/tree/master/algorithm/Bayes&quot; title=&quot;贝叶斯算法&quot;&gt;贝叶斯算法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xiangdong1987/python_data_analysis/tree/master/algorithm/decisionTree&quot; title=&quot;决策树算法&quot;&gt;决策树算法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xiangdong1987/python_data_analysis/tree/master/algorithm/svm&quot; title=&quot;SVM算法&quot;&gt;SVM算法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xiangdong1987/python_data_analysis/tree/master/algorithm/KNN&quot; title=&quot;KNN算法&quot;&gt;KNN算法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过用不同的算法对不同的数据类型就行预测，而得到我们想要预测的模型，这个整个过程就是大数据分析，大数据关键问题就是数据。&lt;/p&gt;

&lt;h2 id=&quot;简单的过程描述&quot;&gt;简单的过程描述&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;我的数据获取是用爬虫对&lt;a href=&quot;http://datachart.500.com/ssq/?expect=100&quot;&gt;http://datachart.500.com/ssq/?expect=100&lt;/a&gt; 的历史数据进行爬去，代码实践请看git。&lt;/li&gt;
  &lt;li&gt;我对数据进行了处理，讲获取的历史数据错开期数进行排序，用当期的数据预测下期的结果。&lt;/li&gt;
  &lt;li&gt;利用svm 多项式回归，对结果进行预测结果越接近1 就是下期出现某数。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;犯过的愚蠢错误&quot;&gt;犯过的愚蠢错误&lt;/h2&gt;
&lt;p&gt;用整个训练集中的一条进行预测，结果发现100% 中奖我以为我发了，好吧是我太蠢了。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;通过预测的结果显示，中一个数据的概率非常小，所有的中奖概率每一期都是8亿分之1，每一次都是独立的事件，是无法根据历史数据来预测的，对于可预测时间必须是一种能线性或者真实存在的某种规律才能进行预测。好吧我的发财梦碎了，老实的板砖吧！&lt;/p&gt;</content><author><name></name></author><summary type="html">起因 我一直有个发财梦，就是靠技术能计算出双色球的走势，从而实现财富自由走向人生巅峰，这个梦一直魂牵梦绕着我，直到最新开始学大数据分析开始，我坚信只要有梦想早晚一天会破碎。 过程 学习过程历时2周，从python语言基础到，大数据分析工具的使用。过程参考下面的github https://github.com/xiangdong1987/python_data_analysis</summary></entry><entry><title type="html">网络不通如何处理</title><link href="/linux/2019/06/18/linux-network.html" rel="alternate" type="text/html" title="网络不通如何处理" /><published>2019-06-18T00:00:00+08:00</published><updated>2019-06-18T00:00:00+08:00</updated><id>/linux/2019/06/18/linux-network</id><content type="html" xml:base="/linux/2019/06/18/linux-network.html">&lt;p&gt;在开发网路应用程序时，网络不通的情话是经常发生的，如果快速查找和定位网络问题就是一个重要的技能。今天来总结一下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第一步，使用ping查看网络是否畅通，如果不畅通需要进一步查看其它方向。&lt;/li&gt;
  &lt;li&gt;第二步，在ping的通的情况家，dig查询CDN情况
    &lt;ul&gt;
      &lt;li&gt;dig 使用
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  dig baidu.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;dig 的5个组成部分
        &lt;ol&gt;
          &lt;li&gt;显示 dig 命令的版本和输入的参数&lt;/li&gt;
          &lt;li&gt;显示服务返回的一些技术详情，比较重要的是 status。如果 status 的值为 NOERROR 则说明本次查询成功结束。&lt;/li&gt;
          &lt;li&gt;“QUESTION SECTION” 显示我们要查询的域名。&lt;/li&gt;
          &lt;li&gt;“ANSWER SECTION” 是查询到的结果。&lt;/li&gt;
          &lt;li&gt;是本次查询的一些统计信息，比如用了多长时间，查询了哪个 DNS 服务器，在什么时间进行的查询&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;记录类型：
        &lt;ul&gt;
          &lt;li&gt;A 指向一个ipv4地址&lt;/li&gt;
          &lt;li&gt;AAAA 指向一个ipv6地址&lt;/li&gt;
          &lt;li&gt;CNAME 将一个域名指向另一个域名&lt;/li&gt;
          &lt;li&gt;MX 如果需要设置邮箱，让邮箱能够收到邮件，需要添加 MX 记录。&lt;/li&gt;
          &lt;li&gt;NS 域名服务器记录，如果需要把子域名交给其他 DNS 服务器解析，就需要添加 NS 记录。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;查询指定记录
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  dig abc.filterinto.com CNAME
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;从指定服务器上查询
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  dig @8.8.8.8 abc.filterinto.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
        &lt;blockquote&gt;
          &lt;p&gt;如果不指定 DNS 服务器，dig 会依次使用 /etc/resolv.conf 里的地址作为 DNS 服务器。&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;反向查询：查询DNS服务器名称
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   dig -x 8.8.8.8 +short
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;TTL 主要是控制 DNS 记录在 DNS 服务器上的缓存时间&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;第三步，如果CDN没有问题的情况下，使用trackroute来检查路由，基本可以断定大部分问题了。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      traceroute www.baidu.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;# 总结
 网络查找问题要从OSI七层中一层一层的查找
 物理层—网线，网卡
 链路层—基本不需要检查
 传输层—检查包是否发出
 网络层—路由是否正确
 会话层以上就是应用层了，检测应用程序是否正常即可。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">在开发网路应用程序时，网络不通的情话是经常发生的，如果快速查找和定位网络问题就是一个重要的技能。今天来总结一下：</summary></entry><entry><title type="html">php组件化实践</title><link href="/php/2019/05/28/php-1.html" rel="alternate" type="text/html" title="php组件化实践" /><published>2019-05-28T00:00:00+08:00</published><updated>2019-05-28T00:00:00+08:00</updated><id>/php/2019/05/28/php-1</id><content type="html" xml:base="/php/2019/05/28/php-1.html">&lt;p&gt;最近学习了go语言，非常钦佩它从语言上对于Coder的友好化，对于它的包规划也感到很用心，其实做为一个phper，我们php也是有很好的工具的，那就是composer,它同样起到了规范化和组件化的作用。一个人的作用总归是有限的，只有集合广大人民的力量才是正道。&lt;/p&gt;

&lt;h1 id=&quot;实践过程&quot;&gt;实践过程&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;组件化什么？
    &lt;ul&gt;
      &lt;li&gt;我一直有个想法做一套后台组件，能快速拼装后台功能，对于一些开源组件，内部实现复杂，自定义困难。所以想自己实现一套可复用的后台组件。 方便以后的开发。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;如何实现组件化？
    &lt;ul&gt;
      &lt;li&gt;对于php来说，composer是不二选择，规范的定义，简单的维护，版本控制，大大减少心理负担。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;如何定义自己的composer 组件？
    &lt;ol&gt;
      &lt;li&gt;实现自己的组件&lt;/li&gt;
      &lt;li&gt;上传github&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;定义composer.json&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; {
   &quot;name&quot;: &quot;xdd/x-template&quot;,    //包名  必须是二级的
   &quot;description&quot;: &quot;后台模板组件&quot;,
   &quot;license&quot;: &quot;MIT&quot;,
   &quot;authors&quot;: [
     {
       &quot;name&quot;: &quot;xdd&quot;,
       &quot;email&quot;: &quot;xiangdong198719@gmail.com&quot;
     }
   ],
   &quot;autoload&quot;: {
     &quot;psr-4&quot;: {
       &quot;Component\\&quot;: &quot;src/component&quot;,    //命名空间目录
       &quot;Interfaces\\&quot;: &quot;src/interface&quot;          //命名空间目录
     }
   },
   &quot;require&quot;: {}
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;在packagist检出自己的github就完成了一个自己的composer&lt;/li&gt;
      &lt;li&gt;composer版本是根据github的tag来创建的只需要给github 打版本标签即可。
        &lt;blockquote&gt;
          &lt;p&gt;根据上面的步骤可以轻松完成组件化
我实现的后台组件模块化 &lt;a href=&quot;https://github.com/xiangdong1987/xTemplate&quot;&gt;https://github.com/xiangdong1987/xTemplate&lt;/a&gt;
希望大家来贡献代码&lt;/p&gt;
          &lt;h1 id=&quot;总结&quot;&gt;总结&lt;/h1&gt;
          &lt;p&gt;最为一个特别懒的程序员，如何把一个复杂重复的工作，做的有趣和简单是我唯一能促使我不断写代码的唯一动力。&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">最近学习了go语言，非常钦佩它从语言上对于Coder的友好化，对于它的包规划也感到很用心，其实做为一个phper，我们php也是有很好的工具的，那就是composer,它同样起到了规范化和组件化的作用。一个人的作用总归是有限的，只有集合广大人民的力量才是正道。</summary></entry><entry><title type="html">Go学习笔记9</title><link href="/go/2019/05/24/Go-9.html" rel="alternate" type="text/html" title="Go学习笔记9" /><published>2019-05-24T00:00:00+08:00</published><updated>2019-05-24T00:00:00+08:00</updated><id>/go/2019/05/24/Go-9</id><content type="html" xml:base="/go/2019/05/24/Go-9.html">&lt;p&gt;包是为了减少重复造轮子，为开发人员减少心智的设计，允许程序员开发公用包或者自己私用的包，减少重复的造轮子。测试也程序员面对的重大问题之一，从我以一个php程序员的角度来看，Go语言的测试工具的设计上也是完爆php，一个成熟的语言测试工具真的是必不可少的。&lt;/p&gt;

&lt;h2 id=&quot;包和工具&quot;&gt;包和工具&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Go一共有100多个标准包可以用下面命令来查看：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;go list std | wc -l
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Go 包编译的特点
    &lt;ul&gt;
      &lt;li&gt;所有的包的导入都要在文件的开头声明，不需要分析整个代码直接编译特定包&lt;/li&gt;
      &lt;li&gt;不允许有循环引入，实现一个有向五环图，加快编译速度，也可以实现单包并发编译&lt;/li&gt;
      &lt;li&gt;编译后的目标文件不仅会导出信息，还记录了包的依赖关系，不需要遍历文件&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;导入路径：都是用字符串表示，由构建起进行解析。&lt;/li&gt;
  &lt;li&gt;包声明：在默认情况下导入包的包名是导入路径的最后一部分，但是也有特殊情况
    &lt;ul&gt;
      &lt;li&gt;main包和导入路径无关，主要是让go build 生成可执行文件&lt;/li&gt;
      &lt;li&gt;_test文件，构建器会忽略当前文件&lt;/li&gt;
      &lt;li&gt;带有版本号的包，也会忽略版本号。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;导入声明可以单独import 也可以用（）来包裹所有包，用换行还可以进行分组，分组中会按照顺序编译。&lt;/li&gt;
  &lt;li&gt;包的匿名导入，如果包不被使用但被导入，编译时会产生错误，但有时候程序设计上需要根据参数导入不同的包，这个时候需要先导入才能使用，所以使用import _ “image/png” 匿名导入的方式，来实现程序功能。&lt;/li&gt;
  &lt;li&gt;包的命名尽量简短，但也不要有歧义，最好拿最主要的实体命名&lt;/li&gt;
  &lt;li&gt;工具：
    &lt;ul&gt;
      &lt;li&gt;有瑞士军刀风格go hlep来看功能&lt;/li&gt;
      &lt;li&gt;在构建之前，工程目录也是要先设置好的&lt;/li&gt;
      &lt;li&gt;go build 会将程序构建到工程目录的 bin 目录下&lt;/li&gt;
      &lt;li&gt;Go 有健全的文档机制，只要我们在导出的函数前，完成注释即可，第一行是摘要，保持简洁，后面的可以任意长度，如果过长也可以单独文件doc.go 文件。&lt;/li&gt;
      &lt;li&gt;godoc 可以生成也浏览的html 页面方便查询。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;普通测试
    &lt;ul&gt;
      &lt;li&gt;_test.go 为文件名的文件，使用go test进行测试&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;测试覆盖率
    &lt;ul&gt;
      &lt;li&gt;覆盖率只是帮助找到代码脆弱的部分&lt;/li&gt;
      &lt;li&gt;go test -v -run=Coverage gopl.io/ch7/eval&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;基准测试
    &lt;ul&gt;
      &lt;li&gt;Benchmark为前缀的&lt;/li&gt;
      &lt;li&gt;测试一个程序在固定工作负载下的性能。&lt;/li&gt;
      &lt;li&gt;go test -bench=. -benchmem&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;性能测试
    &lt;ul&gt;
      &lt;li&gt;对于cpu 阻塞 和 内存的使用都可以用go test 进行测试。
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ go test -cpuprofile=cpu.out
  $ go test -blockprofile=block.out
  $ go test -memprofile=mem.out
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;Go 的包设计和工具的设计都是为了更好的方便程序员代码的开发和合理的利用，这种设计思想只有多年从事coder的人才能体会其中的妙用，测试也是解放了我们debug的时间，我觉得程序员都是懒的，只有懒才能触发我们的创造力，解放我们的时间，让我们有更多的时间做创造性的工作。&lt;/p&gt;</content><author><name></name></author><summary type="html">包是为了减少重复造轮子，为开发人员减少心智的设计，允许程序员开发公用包或者自己私用的包，减少重复的造轮子。测试也程序员面对的重大问题之一，从我以一个php程序员的角度来看，Go语言的测试工具的设计上也是完爆php，一个成熟的语言测试工具真的是必不可少的。</summary></entry><entry><title type="html">Go学习笔记8</title><link href="/go/2019/05/15/Go-8.html" rel="alternate" type="text/html" title="Go学习笔记8" /><published>2019-05-15T00:00:00+08:00</published><updated>2019-05-15T00:00:00+08:00</updated><id>/go/2019/05/15/Go-8</id><content type="html" xml:base="/go/2019/05/15/Go-8.html">&lt;p&gt;前面的学习，只学习了直接使用goroutine和channel的并发程序，忽略其他细微问题，尤其在包含共享变量的并发程序，接下来我们来学习，有共享变量的并发程序。&lt;/p&gt;

&lt;h2 id=&quot;竞争条件&quot;&gt;竞争条件&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;一般情况下我们没法去知道分别位于两个goroutine的事件x和y的执行顺序，x是在y之前还是之后还是同时发生是没法判断的。当我们能够没有办法自信地确认一个事件是在另一个事件的前面或者后面发生的话，就说明x和y这两个事件是并发的。
    &lt;ul&gt;
      &lt;li&gt;并发安全：一个函数在线性程序中可以正确地工作。如果在并发的情况下，这个函数依然可以正确地工作的话，那么我们就说这个函数是并发安全的，并发安全的函数不需要额外的同步工作&lt;/li&gt;
      &lt;li&gt;非并发安全：反之。单并发非安全的程序也可以通过某些方式变成线程安全的，并发安全的类型是例外，而不是规则，所以只有当文档中明确地说明了其是并发安全的情况下，你才可以并发地去访问它
        &lt;blockquote&gt;
          &lt;p&gt;导出包级别的函数一般情况下都是并发安全的。由于package级的变量没法被限制在单一的gorouine，所以修改这些变量“必须”使用互斥条件。&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;竞争条件：竞争条件指的是程序在多个goroutine交叉执行操作时，没有给出正确的结果。竞争条件是很恶劣的一种场景，因为这种问题会一直潜伏在你的程序里，然后在非常少见的时候蹦出来，或许只是会在很大的负载时才会发生，又或许是会在使用了某一个编译器、某一种平台或者某一种架构的时候才会出现。这些使得竞争条件带来的问题非常难以复现而且难以分析诊断。&lt;/li&gt;
  &lt;li&gt;如何避免竞争条件
    &lt;ul&gt;
      &lt;li&gt;第一种方法是不要去写变量。（不太可能）&lt;/li&gt;
      &lt;li&gt;第二种避免数据竞争的方法是，避免从多个goroutine访问变量。&lt;/li&gt;
      &lt;li&gt;第三种避免数据竞争的方法是允许很多goroutine去访问变量，但是在同一个时刻最多只有一个goroutine在访问。这种方式被称为“互斥”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;syncmutex互斥锁&quot;&gt;sync.Mutex互斥锁&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;前面学习的时候我们可以利用buffer channel控制gorontine的深度，如果我们用buffer等于的channel 就可以控制变量的访问如下代码：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var (
    sema    = make(chan struct{}, 1) // a binary semaphore guarding balance
    balance int
)

func Deposit(amount int) {
    sema &amp;lt;- struct{}{} // acquire token
    balance = balance + amount
    &amp;lt;-sema // release token
}

func Balance() int {
    sema &amp;lt;- struct{}{} // acquire token
    b := balance
    &amp;lt;-sema // release token
    return b
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;这种互斥很实用，而且被sync包里的Mutex类型直接支持。它的Lock方法能够获取到token(这里叫锁)，并且Unlock方法会释放这个token&lt;/li&gt;
  &lt;li&gt;在锁之间的区域叫做临界区，为了使用临界区的临界关闭正确一般我会选择使用defer来控制临界区的关闭。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func Balance() int {
    mu.Lock()
    defer mu.Unlock()
    return balance
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Go 是没有重入锁的（java中是有重入锁：锁上锁）关于Go的互斥量不能重入这一点我们有很充分的理由。互斥量的目的是为了确保共享变量在程序执行时的关键点上能够保证不变性。不变性的其中之一是“没有goroutine访问共享变量”。&lt;/li&gt;
  &lt;li&gt;所以在包的封装上，一个通用的解决方案是将一个函数分离为多个函数，比如我们把Deposit分离成两个：一个不导出的函数deposit，这个函数假设锁总是会被保持并去做实际的操作，另一个是导出的函数Deposit，这个函数会调用deposit，但在调用前会先去获取锁。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;syncrwmutex读写锁&quot;&gt;sync.RWMutex读写锁&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;利用互斥锁，会将变量的读也锁住，如果系统中包含大量的读操作，互斥锁就完全限制了系统的功能。所以Go支持读写锁，只有在写的时候会锁定。&lt;/li&gt;
  &lt;li&gt;RWMutex只有当获得锁的大部分goroutine都是读操作，而锁在竞争条件下，也就是说，goroutine们必须等待才能获取到锁的时候，RWMutex才是最能带来好处的。RWMutex需要更复杂的内部记录，所以会让它比一般的无竞争锁的mutex慢一些
    &lt;h2 id=&quot;synconce初始化&quot;&gt;sync.Once初始化&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;有些时候当我们初始化一些慢操作时，如果不使用锁机制进行控制的话，会造成非并发安全的情况。所以时候需要同时使用互斥锁和读写锁&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var mu sync.RWMutex // guards iconsvar icons map[string]image.Image
// Concurrency-safe.func Icon(name string) image.Image {
    mu.RLock()
    if icons != nil {
        icon := icons[name]
        mu.RUnlock()
        return icon
    }
    mu.RUnlock()

    // acquire an exclusive lock
    mu.Lock()
    if icons == nil { // NOTE: must recheck for nil
        loadIcons()
    }
    icon := icons[name]
    mu.Unlock()
    return icon
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;这样写比较麻烦所以Go使用了sync.Once简化了整个流程&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var loadIconsOnce sync.Once
var icons map[string]image.Image
// Concurrency-safe.
func Icon(name string) image.Image {
    loadIconsOnce.Do(loadIcons)
    return icons[name]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;竞争条件检测&quot;&gt;竞争条件检测&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;即使我们小心到不能再小心，但在并发程序中犯错还是太容易了。幸运的是，Go的runtime和工具链为我们装备了一个复杂但好用的动态分析工具，竞争检查器(the race detector)。只要在go build，go run或者go test命令后面加上-race的flag，就会使编译器创建一个你的应用的“修改”版或者一个附带了能够记录所有运行期对共享变量访问工具的test，并且会记录下每一个读或者写共享变量的goroutine的身份信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;并发无阻塞&quot;&gt;并发无阻塞&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;想实现并发无阻塞，必须避免竞争条件的产生。一下实现了一个并发无阻塞的缓存。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type entry struct {
    res   result
    ready chan struct{} // closed when res is ready
}

func New(f Func) *Memo {
    return &amp;amp;Memo{f: f, cache: make(map[string]*entry)}
}

type Memo struct {
    f     Func
    mu    sync.Mutex // guards cache
    cache map[string]*entry
}

func (memo *Memo) Get(key string) (value interface{}, err error) {
    memo.mu.Lock()
    e := memo.cache[key]
    if e == nil {
        // This is the first request for this key.
        // This goroutine becomes responsible for computing
        // the value and broadcasting the ready condition.
        e = &amp;amp;entry{ready: make(chan struct{})}
        memo.cache[key] = e
        memo.mu.Unlock()

        e.res.value, e.res.err = memo.f(key)

        close(e.ready) // broadcast ready condition
    } else {
        // This is a repeat request for this key.
        memo.mu.Unlock()

        &amp;lt;-e.ready // wait for ready condition
    }
    return e.res.value, e.res.err
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;以上利用ready channel 实现了读广播，变量是否准备完毕。使用特性是当一个无buffer的channel会阻塞读取channel的代码位置，当关闭channel时，是会通知到读取的地方channel已经关闭，并不产生错误（但是向已经关闭的channel，传输数据会产生painc）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;goroutine和线程&quot;&gt;Goroutine和线程&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;栈空间的区别
    &lt;ul&gt;
      &lt;li&gt;线程的栈是固定大小的2m&lt;/li&gt;
      &lt;li&gt;Goroutine初始是2k，可以根据程序的变化动态改变，最大有1GB，在Go中叫动态栈。
        &lt;blockquote&gt;
          &lt;p&gt;知识点：
栈：一个栈的作用是用来保存函数调用上下文和内部变量&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;调度的区别
    &lt;ul&gt;
      &lt;li&gt;线程间的切换时需要保存线程上下文，切换到替他线程，是利用系统的shedule函数，由cup来调度。&lt;/li&gt;
      &lt;li&gt;Goruntine的切换是在，go Runtime 中实现的，由Go本身控制调度，并且采用了一种n:m的方式，利用n个系统线程分别处理m个Goruntine，所以一个goruntine的切换消耗比线程小的多
        &lt;blockquote&gt;
          &lt;p&gt;线程相比Goroutine它多调用了局部内存，增加了cpu运行周期（由于切换和读内存引起的）
Goruntine 的调度方式也类似系统的调度方式
GOMAXPROCS 参数是用来设定Go用多少个系统线程同时工作。&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;自身标识
    &lt;ul&gt;
      &lt;li&gt;线程是有线程id的&lt;/li&gt;
      &lt;li&gt;Goruntine是没有的，原因是防止由于thread-local storage（TLS）总是会被滥用，所引起的过分依赖线程的局部变量，程序变幻莫测。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结：&lt;/h2&gt;
&lt;p&gt;并发带来的问题就是，竞争条件，如果竞争条件不处理好，会造成意料不到的结果。所以并发主要处理的就是竞争条件问题，处理竞争条件主要有如下三个方向：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;避免写操作&lt;/li&gt;
  &lt;li&gt;避免从多个goroutine，写入数据&lt;/li&gt;
  &lt;li&gt;允许多个goruntine访问一个变量，但是同一时刻只能有一个能访问，就是互斥
第一种方式，使用的场景特别少，只有少量静态服务才会这样使用。
第二种方式，在设计时，由一个主Goruntine去处理些操作，其他Goruntine作为生产者利用channel处理
第三种方式，允许多个Goruntine写变量，但是同一时刻只能有一个可以生效，利用互斥锁+channel广播的形式实现并发非阻塞
Go实现并发的优势主要是在goruntine和线程的区别和自身的runtime并发调度，优化了线程调度之间的损耗，实现了更高效的并发。&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">前面的学习，只学习了直接使用goroutine和channel的并发程序，忽略其他细微问题，尤其在包含共享变量的并发程序，接下来我们来学习，有共享变量的并发程序。</summary></entry><entry><title type="html">Go学习笔记7</title><link href="/go/2019/05/09/Go-7.html" rel="alternate" type="text/html" title="Go学习笔记7" /><published>2019-05-09T00:00:00+08:00</published><updated>2019-05-09T00:00:00+08:00</updated><id>/go/2019/05/09/Go-7</id><content type="html" xml:base="/go/2019/05/09/Go-7.html">&lt;p&gt;重头戏要来了，并发编程。这是Go的主打优势，Go通过自身设计层面，隐藏了比较晦涩难懂的并发过程，我们只需要通过goroutine和channel的配合就能实现自己想要的并发程序，实现CSP（communicating sequential processes）并发变成模型，像我这么懒得人特别喜欢站在巨人的肩膀上眺望。&lt;/p&gt;

&lt;h2 id=&quot;goroutines&quot;&gt;Goroutines&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;在Go语言中，每一个并发的执行单元叫作一个goroutine。&lt;/li&gt;
  &lt;li&gt;当一个程序启动时，其主函数即在一个单独的goroutine中运行，我们叫它main goroutine。新的goroutine会用go语句来创建。在语法上，go语句是一个普通的函数或方法调用前加上关键字go。go语句会使其语句中的函数在一个新创建的goroutine中运行。而go语句本身会迅速地完成。&lt;/li&gt;
  &lt;li&gt;Goroutines是并发体
    &lt;h2 id=&quot;channels&quot;&gt;Channels&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;如果说goroutine是Go语言程序的并发体的话，那么channels则是它们之间的通信机制。&lt;/li&gt;
  &lt;li&gt;channels 就是一个顺序的消息队列可分为下面两类
    &lt;ul&gt;
      &lt;li&gt;有buffer的channel:
        &lt;ul&gt;
          &lt;li&gt;读取时：队列非空不阻塞&lt;/li&gt;
          &lt;li&gt;写入时：队列非满不阻塞&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;有buffer示例代码：
  ```
  func mirroredQuery() string {
  responses := make(chan string, 3)
  go func() { responses &amp;lt;- request(“asia.gopl.io”) }()
  go func() { responses &amp;lt;- request(“europe.gopl.io”) }()
  go func() { responses &amp;lt;- request(“americas.gopl.io”) }()
  return &amp;lt;-responses // return the quickest response
  }&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;func request(hostname string) (response string) { /* … */ }
  ```&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;p&gt;如果我们使用了无缓存的channel，那么两个慢的goroutines将会因为没有人接收而被永远卡住。这种情况，称为goroutines泄漏，这将是一个BUG。和垃圾变量不同，泄漏的goroutines并不会被自动回收，因此确保每个不再需要的goroutine能正常退出是重要的。&lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;没有buffer的channel
          &lt;ul&gt;
            &lt;li&gt;读取时：有写入不阻塞&lt;/li&gt;
            &lt;li&gt;写入时：空channnel不阻塞&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;串联channnel实现pipeline。让各个程序同时并发处理&lt;/li&gt;
  &lt;li&gt;使用单方向的channel 避免一些异常写入和读取&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func counter(out chan&amp;lt;- int) {
    for x := 0; x &amp;lt; 100; x++ {
        out &amp;lt;- x
    }
    close(out)
}

func squarer(out chan&amp;lt;- int, in &amp;lt;-chan int) {
    for v := range in {
        out &amp;lt;- v * v
    }
    close(out)
}

func printer(in &amp;lt;-chan int) {
    for v := range in {
        fmt.Println(v)
    }
}

func main() {
    naturals := make(chan int)
    squares := make(chan int)
    go counter(naturals)
    go squarer(squares, naturals)
    printer(squares)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Channel的缓存也可能影响程序的性能。想象一家蛋糕店有三个厨师，一个烘焙，一个上糖衣，还有一个将每个蛋糕传递到它下一个厨师在生产线。在狭小的厨房空间环境，每个厨师在完成蛋糕后必须等待下一个厨师已经准备好接受它；这类似于在一个无缓存的channel上进行沟通。&lt;/li&gt;
  &lt;li&gt;合理的设置缓存，就是合理的利用生产者和消费者之间的关系。尽量不要过度生产或者过度消费&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;并发循环&quot;&gt;并发循环&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;利用循环迭代进行并发是最长见的并发模型，如果不在main gorouintine 进行控制程序会瞬间执行完毕，不等待其他goroutine 完成，所以一般我们会用channel进行控制代码如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// makeThumbnails3 makes thumbnails of the specified files in parallel.func makeThumbnails3(filenames []string) {
    ch := make(chan struct{})
    for _, f := range filenames {
        go func(f string) {
            thumbnail.ImageFile(f) // NOTE: ignoring errors
            ch &amp;lt;- struct{}{}
        }(f)
    }
    // Wait for goroutines to complete.
    for range filenames {
        &amp;lt;-ch
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;前面讲的都是知道并行次数的情况，在不知道并行次数的情况下我们需要一个完全的计数器来控制并行的结束，通过sync.WaitGroup来控制循环进程结束
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// makeThumbnails6 makes thumbnails for each file received from the channel.
// It returns the number of bytes occupied by the files it creates.
func makeThumbnails6(filenames &amp;lt;-chan string) int64 {
  sizes := make(chan int64)
  var wg sync.WaitGroup // number of working goroutines
  for f := range filenames {
      wg.Add(1)
      // worker
      go func(f string) {
          defer wg.Done()
          thumb, err := thumbnail.ImageFile(f)
          if err != nil {
              log.Println(err)
              return
          }
          info, _ := os.Stat(thumb) // OK to ignore error
          sizes &amp;lt;- info.Size()
      }(f)
  }

  // closer
  go func() {
      wg.Wait()
      close(sizes)
  }()

  var total int64
  for size := range sizes {
      total += size
  }
  return total
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;时序图如下：
&lt;img src=&quot;/images/11.png&quot; alt=&quot;设置1&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;实例分析&quot;&gt;实例分析&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;网络爬虫
    &lt;ul&gt;
      &lt;li&gt;工作channel,用于保存正在抓取的链接&lt;/li&gt;
      &lt;li&gt;接受命令行的goroutine&lt;/li&gt;
      &lt;li&gt;记录访问记录的map&lt;/li&gt;
      &lt;li&gt;循环消耗工作channel&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;优化思路
    &lt;ul&gt;
      &lt;li&gt;当无限开启goroutine时，会造打开过多的文件描述符，所以我们必须控制goroutine的数量，这个时候我们需要一个新的channel，token的channel,相当于令牌桶合理的有缓存channel 当做令牌桶,在go的函数获取令牌，执行结束后释放令牌。&lt;/li&gt;
      &lt;li&gt;如何防止无限抓取，要检查工作channel是否已经完成
        &lt;h2 id=&quot;多路复用select&quot;&gt;多路复用select&lt;/h2&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;当你有多个channel 想同时检测时你可以使用select，它保证随机的获取你要检测的channel代码如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
func main() {
    // ...create abort channel...

    fmt.Println(&quot;Commencing countdown.  Press return to abort.&quot;)
    tick := time.Tick(1 * time.Second)
    for countdown := 10; countdown &amp;gt; 0; countdown-- {
        fmt.Println(countdown)
        select {
        case &amp;lt;-tick:
            // Do nothing.
        case &amp;lt;-abort:
            fmt.Println(&quot;Launch aborted!&quot;)
            return
        }
    }
    launch()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;并发编程并不像，想象的那么难，也没有说的那么容易，其中很多方式方法还是需要在不断的学习和实践中总结比如：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;channel 有误buffer选用&lt;/li&gt;
  &lt;li&gt;goroutine 泄漏问题&lt;/li&gt;
  &lt;li&gt;goroutine 开启的限制&lt;/li&gt;
  &lt;li&gt;程序结束的限制&lt;/li&gt;
  &lt;li&gt;并发深度的限制等等
只有不断学习和实践才是做为一名coder 的终身事业。&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">重头戏要来了，并发编程。这是Go的主打优势，Go通过自身设计层面，隐藏了比较晦涩难懂的并发过程，我们只需要通过goroutine和channel的配合就能实现自己想要的并发程序，实现CSP（communicating sequential processes）并发变成模型，像我这么懒得人特别喜欢站在巨人的肩膀上眺望。</summary></entry></feed>