<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2019-04-05T15:11:17+08:00</updated><id>/feed.xml</id><title type="html">一叶障目</title><subtitle>学无止境</subtitle><entry><title type="html">如何搭建本地docker registry</title><link href="/docker/2019/04/03/docker-local-registry.html" rel="alternate" type="text/html" title="如何搭建本地docker registry" /><published>2019-04-03T00:00:00+08:00</published><updated>2019-04-03T00:00:00+08:00</updated><id>/docker/2019/04/03/docker-local-registry</id><content type="html" xml:base="/docker/2019/04/03/docker-local-registry.html">&lt;p&gt;学习k8s制作镜像就是毕竟之路，而如果想要一个快速的仓库，本地仓库就是首选，所以学习单间本地dock registry很重要。&lt;/p&gt;

&lt;h2 id=&quot;获取镜像&quot;&gt;获取镜像&lt;/h2&gt;

&lt;p&gt;拉取远程镜像用于制作本地镜像&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-angular2html&quot;&gt;docker pull nginx:alpine
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;本地docker-registry&quot;&gt;本地docker registry&lt;/h2&gt;
&lt;p&gt;拉取docker registry&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-angular2html&quot;&gt;docker pull registry:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行docker registry&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-angular2html&quot;&gt;docker run \
  --detach \
  --name registry \
  --hostname registry \
  --volume $(pwd)/registry:/var/lib/registry/docker/registry \
  --publish 5000:5000 \
  --restart unless-stopped \
  registry:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;制作镜像&quot;&gt;制作镜像&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;利用DockerFile制作镜像&lt;/li&gt;
  &lt;li&gt;先将环境拉取到本地&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-angular2html&quot;&gt;//拉取官方php
docker pull php:7.1-cli-jessie
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;进入docker进行环境配置记录配置命令制作DockerFile&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-angular2html&quot;&gt;docker run -it php:7.1-cli-jessie /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/xiangdong1987/local-env/tree/master&quot;&gt;根据官方PHP镜像修改后的Dockerfile&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;容器相关命令&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-angular2html&quot;&gt;//容器属性
sudo docker inspect 6d4a2498c108 (容器id)
//容器ip
docker inspect [container_name] | grep IPAddress
//端口转发
iiptables -t nat -A DOCKER -p tcp -dport 8001 -j DNAT --to-destination 192.169.1.1:8080
//容器查看
sudo docker ps  /-a 
//删除容器
sudo docker rm 容器id
//容器镜像查看
sudo docker images 
//删除镜像
sudo docker image rm 镜像id
//运行docker -p 映射端口  -v 挂在目录  -it 进入容器
sudo docker run -p 8810:8810 -it chelun-test:v1 -v /data:/data /bin/bash

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;镜像的制作就是一个环境搭建的流程，需要细心的记录没一部操作，也要合理话层级。尽量用少的层级来实现环境的待见。后面的路还很长需要继续学习。&lt;/p&gt;</content><author><name></name></author><summary type="html">学习k8s制作镜像就是毕竟之路，而如果想要一个快速的仓库，本地仓库就是首选，所以学习单间本地dock registry很重要。</summary></entry><entry><title type="html">linux 高性能学习笔记9</title><link href="/linux/2019/04/02/linux-high-9.html" rel="alternate" type="text/html" title="linux 高性能学习笔记9" /><published>2019-04-02T00:00:00+08:00</published><updated>2019-04-02T00:00:00+08:00</updated><id>/linux/2019/04/02/linux-high-9</id><content type="html" xml:base="/linux/2019/04/02/linux-high-9.html">&lt;p&gt;同CUP管理一样，内存管理也是操作系统最核心的功能之。内存主要用来存储系统和应用程序的指令，数据，缓存等。&lt;/p&gt;

&lt;h2 id=&quot;内存映射&quot;&gt;内存映射&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;通常说的8G内存指的是物理内存也成主存&lt;/li&gt;
  &lt;li&gt;进程是不可以直接访问物理内存，只有cpu可以直接访问物理内存&lt;/li&gt;
  &lt;li&gt;大多数的主存都是动态随机访问内存（DRAM）&lt;/li&gt;
  &lt;li&gt;linux 为每个进程分配一个独立的虚拟地址空间，并且是连续的。&lt;/li&gt;
  &lt;li&gt;虚拟内存空间也被分为内核空间和用户空间。&lt;/li&gt;
  &lt;li&gt;根据cpu指令可以处理数据的最大长度32位和64位&lt;/li&gt;
  &lt;li&gt;32位cpu 最长寻址空间是4G  1G 系统空间 3G 用户空间&lt;/li&gt;
  &lt;li&gt;64位cpu 最长寻址空间是17179869184G
    &lt;ul&gt;
      &lt;li&gt;头128T 系统空间&lt;/li&gt;
      &lt;li&gt;位128T 用户空间&lt;/li&gt;
      &lt;li&gt;其他 其他空间&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;每个进程都有用户态和内核态，所有的虚拟内存加起来一定大于物理内存，所以并不是所有虚拟内存都分配物理内存，只有那些实际使用的虚拟内存才分配物理内存，并且分配后的物理内存，是通过 &lt;strong&gt;内存映射&lt;/strong&gt; 来管理的。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;img src=&quot;/images/6.png&quot; alt=&quot;设置1&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;MMU(Memory Management Unit)内存管理单元，用于存储页表&lt;/li&gt;
  &lt;li&gt;每个进程都有一个对应的页表来做内存映射&lt;/li&gt;
  &lt;li&gt;当虚拟地址在页表种查找不到地址时 &lt;strong&gt;缺页异常&lt;/strong&gt; 进入内核空间分配物理内存，更新进程页表，最后返回用户空间，恢复进程运行。&lt;/li&gt;
  &lt;li&gt;MMU的最小单位是4KB称作&lt;strong&gt;页&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;由于页大小只有4KB，加入在32位系统中，就会有100多万的页表才能实现整个地址空间的映射。为了解决页表项过多的问题，linux提供两种机制
    &lt;ul&gt;
      &lt;li&gt;多级页表：吧内存分成区块来管理，讲原来的映射关系改成区块索引和区块内的偏移。由于虚拟内存空间通常只用很少一部分，那么多级页表就只保存这些使用中的区块，这样就可以大大地减少页表的项数&lt;/li&gt;
      &lt;li&gt;&lt;img src=&quot;/images/7.png&quot; alt=&quot;设置1&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;大页：不明思议就是更大的内存块，常见2MB和1GB，多用于使用大量内存的进程上，比如Oracle,DPDK等&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;虚拟内存空间的分布&quot;&gt;虚拟内存空间的分布&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;img src=&quot;/images/8.png&quot; alt=&quot;设置1&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;从低到高分五种不同的内存段：
    &lt;ol&gt;
      &lt;li&gt;只读段，包括代码和常量等&lt;/li&gt;
      &lt;li&gt;数据段，包括全局变量等&lt;/li&gt;
      &lt;li&gt;堆，包括动态分配的内存，从低地址开始向上增长&lt;/li&gt;
      &lt;li&gt;文件映射段，包括动态库，共享内存等，从高地址开始向下增长&lt;/li&gt;
      &lt;li&gt;栈，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是8MB&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;内存分配与回收&quot;&gt;内存分配与回收&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;c语言使用malloc()方法分配内存
    &lt;ul&gt;
      &lt;li&gt;brk() 在c 标准库中当分配的内存小于128K默认使用brk()，当使用完成后并不会直接释放，而是缓存起来继续使用
        &lt;ul&gt;
          &lt;li&gt;缺点：在系统繁忙时容易产生内存碎片&lt;/li&gt;
          &lt;li&gt;优点：可以减少缺页异常的发生&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;mmap() 在大于128K使用mmap()分配内存
        &lt;ul&gt;
          &lt;li&gt;缺点：频繁的分配内存，容易产生缺页异常&lt;/li&gt;
          &lt;li&gt;优点：直接释放内存&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;对于内存来说，如果只分配而不释放，就会造成内存泄漏，甚至会耗尽内存。所有应用程序使用完内存后，还需要调用free()或unmap(),来释放这些不用的内存。&lt;/li&gt;
  &lt;li&gt;系统自身也不会任由应用程序的进程用完所有内存的，在发现内存紧张时，系统就会通过一系列机制来回收内存，比如下面这三种方式：
    &lt;ul&gt;
      &lt;li&gt;回收缓存，比如使用LRU算法，回收最近使用最少的内存页&lt;/li&gt;
      &lt;li&gt;回收不常访问的内存，把不常用的内存通过交换分区直接写到磁盘中（会使用交换分区Swap）&lt;/li&gt;
      &lt;li&gt;杀死进程，内存紧张时系统还会通过OOM(Out of Memory),直接杀掉占用大量内存的进程。
        &lt;ul&gt;
          &lt;li&gt;是一种内核保护机制&lt;/li&gt;
          &lt;li&gt;使用oom_score记录每个进程的使用内存评分&lt;/li&gt;
          &lt;li&gt;一个进程消耗的内存越大，oom_score就越大&lt;/li&gt;
          &lt;li&gt;一个进程运行占用的CPU越多，oom_score就越小&lt;/li&gt;
          &lt;li&gt;管理员可以手动设置oom_adj,oom_adj的范围[-17,15] 数值越大，表示进程越容易被OOM杀死，-17表示禁止OOM&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;如何查看内存使用情况&quot;&gt;如何查看内存使用情况&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;free 查看内存使用情况
    &lt;ul&gt;
      &lt;li&gt;total 是内存总大小&lt;/li&gt;
      &lt;li&gt;used 已使用的内存的大小，包好了共享内存&lt;/li&gt;
      &lt;li&gt;free 是未使用内存的大小&lt;/li&gt;
      &lt;li&gt;shared 是共享内存的大小&lt;/li&gt;
      &lt;li&gt;buff/cache 是缓存和缓冲区的大小&lt;/li&gt;
      &lt;li&gt;available 是进程可用内存的大小&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;top查看每个进程使用内存情况
    &lt;ul&gt;
      &lt;li&gt;VIRT 是进程虚拟内存的大小&lt;/li&gt;
      &lt;li&gt;RES 是常住内存的大小，进程实际使用物理内存的大小，不包含Swap和共享内存。&lt;/li&gt;
      &lt;li&gt;SHR 是共享内存的大小，比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等。&lt;/li&gt;
      &lt;li&gt;%MEM 是进程使用物理内存占系统内存的百分比&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;buffer-和-cache&quot;&gt;Buffer 和 Cache&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;通常理解buffer是写入时合并写入，加快写入速度的&lt;/li&gt;
  &lt;li&gt;通常理解cache是读取磁盘文件的页缓存，加快速度读取的&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;linux-文件系统&quot;&gt;linux 文件系统&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;在linux内所有一切皆文件&lt;/li&gt;
  &lt;li&gt;文件分为好多类型（ls -l /dev）：
    &lt;ul&gt;
      &lt;li&gt;-：普通文件&lt;/li&gt;
      &lt;li&gt;d: 目录&lt;/li&gt;
      &lt;li&gt;l：链接&lt;/li&gt;
      &lt;li&gt;d: 块文件&lt;/li&gt;
      &lt;li&gt;c: 字符串文件&lt;/li&gt;
      &lt;li&gt;s: socket文件&lt;/li&gt;
      &lt;li&gt;p: 管道文件&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;磁盘会分区块，系统在每个区块上建立文件系统，在文件系统下创建目录，在目录中创建文件。
    &lt;ul&gt;
      &lt;li&gt;普通文件就是目录中的文件，他的读写基于文件系统&lt;/li&gt;
      &lt;li&gt;块文件，就是磁盘空间，他的读写会跳过文件系统&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;对于以上的两种文件的读写，系统用了不同的优化方式
    &lt;ul&gt;
      &lt;li&gt;普通文件：cache&lt;/li&gt;
      &lt;li&gt;块文件：buffer&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;以上就是cache和buffer的本质区别。&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">同CUP管理一样，内存管理也是操作系统最核心的功能之。内存主要用来存储系统和应用程序的指令，数据，缓存等。</summary></entry><entry><title type="html">linux 高性能学习笔记8</title><link href="/linux/2019/03/29/linux-high-8.html" rel="alternate" type="text/html" title="linux 高性能学习笔记8" /><published>2019-03-29T16:39:26+08:00</published><updated>2019-03-29T16:39:26+08:00</updated><id>/linux/2019/03/29/linux-high-8</id><content type="html" xml:base="/linux/2019/03/29/linux-high-8.html">&lt;p&gt;针对cup瓶颈的问题分析了很多，相应的分析工具也介绍了不少，但理解了各种指标的含义后，会发现他们之间是有一定关联性的。顺着关联是可以很快找到瓶颈所在。找到瓶颈下一步就是进行优化。&lt;/p&gt;
&lt;h2 id=&quot;方法论&quot;&gt;方法论&lt;/h2&gt;
&lt;p&gt;可以从下面三个问题出发来判断性能优化是否有效&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;如何判断性能优化的有效性？&lt;/li&gt;
  &lt;li&gt;性能问题通常不是独立问的，如果同时发生先优化哪一个？&lt;/li&gt;
  &lt;li&gt;提升性能的方法并不唯一的，当有多钟选择时，改选哪一种？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果你能轻松的回答这三个问题就可以开始优化了&lt;/p&gt;
&lt;h3 id=&quot;细化三个问题&quot;&gt;细化三个问题&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;如何评估性能效果
    &lt;ol&gt;
      &lt;li&gt;确定性能的量化指标
        &lt;ul&gt;
          &lt;li&gt;cpu使用率&lt;/li&gt;
          &lt;li&gt;应用程序吞吐量&lt;/li&gt;
          &lt;li&gt;客户端请求的延迟
            &lt;blockquote&gt;
              &lt;p&gt;建议不要局限在单一纬度上来定指标
应用程序纬度：吞吐量和请求延迟
系统资源纬度：cpu使用率&lt;/p&gt;
            &lt;/blockquote&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;测试优化前的性能指标
        &lt;blockquote&gt;
          &lt;p&gt;注意：&lt;/p&gt;
          &lt;ol&gt;
            &lt;li&gt;尽量避免性能测试工具干扰应用程序的性能，防止交叉污染&lt;/li&gt;
            &lt;li&gt;避免外部环境的变化影响性能指标的评估&lt;/li&gt;
          &lt;/ol&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;测试优化后的性能指标&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;多个性能问题同时存在，要怎么选？
    &lt;ul&gt;
      &lt;li&gt;二八原则：80%的问题都是由20%的代码导致的，只要找到20%就可以了，&lt;em&gt;并不是所有的性能问题都值得优化&lt;/em&gt;
        &lt;ol&gt;
          &lt;li&gt;如果资源达到瓶颈，比如cpu使用率到了100%，那么首先优化一定是系统资源使用问题。优化后再考虑其他问题。&lt;/li&gt;
          &lt;li&gt;针对不同类型的指标，首先优化那些由瓶颈导致的，性能指标变化幅度最大的问题，比如产生瓶颈后，用户cpu使用率升高了10%，而系统cpu使用率却升高了50%，这个时候首先应该优化cpu使用率。&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;多种优化方法时，如何选择？
    &lt;ul&gt;
      &lt;li&gt;&lt;em&gt;性能优化并非没有成本&lt;/em&gt; 当你优化一个指标，有可能另一个指标却上升了。&lt;/li&gt;
      &lt;li&gt;比如网络优化中的DPDK（Data Plane Development Kit）提升网络的处理能力。它需要独占一个cpu以及一定数量的内存大页，CPU核数较少是并不适合用这种优化。
        &lt;h3 id=&quot;几大优化方向&quot;&gt;几大优化方向&lt;/h3&gt;
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* CPU优化
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;应用程序优化：排除所有不必要的工作，只保留核心的逻辑。比如减少循环层次，减少递归，减少动态内存分配等等
        &lt;ul&gt;
          &lt;li&gt;编译器优化：gcc&lt;/li&gt;
          &lt;li&gt;算法优化：减少算法复杂度&lt;/li&gt;
          &lt;li&gt;异步处理：轮训改为事件通知&lt;/li&gt;
          &lt;li&gt;多线程代替多进程：减少上下文切换&lt;/li&gt;
          &lt;li&gt;善用缓存：减少磁盘操作，直接使用缓存&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;系统优化：
        &lt;ul&gt;
          &lt;li&gt;cpu绑定：把进程绑定到一个或者多个cpu上，可以提高cpu缓存命中率，减少跨cpu调度带来的上下文切换&lt;/li&gt;
          &lt;li&gt;cpu独占：类似绑定，独占cpu&lt;/li&gt;
          &lt;li&gt;优先级调整：减低非核心业务的应用优先级&lt;/li&gt;
          &lt;li&gt;为进程设置资源限制：使用linux cgroups 来设置进程的cpu使用上线。&lt;/li&gt;
          &lt;li&gt;NUMA(Non-Uniform Memory Access)优化：支持NUMA的cup，会被划分为多个node,每个都有自己的本地内存地址。&lt;/li&gt;
          &lt;li&gt;中断负载均衡：开启irqbalance服务或者配置smp_affinity,把中断处理自动负载均衡到多个cpu
            &lt;blockquote&gt;
              &lt;p&gt;注意:
&lt;em&gt;避免过早优化&lt;/em&gt;：&lt;/p&gt;
              &lt;ol&gt;
                &lt;li&gt;优化带来复杂性的提升，降低可维护性。&lt;/li&gt;
                &lt;li&gt;需求是动态变化的，要针对当前情况进行优化，是个动态的过程。&lt;/li&gt;
              &lt;/ol&gt;
            &lt;/blockquote&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">针对cup瓶颈的问题分析了很多，相应的分析工具也介绍了不少，但理解了各种指标的含义后，会发现他们之间是有一定关联性的。顺着关联是可以很快找到瓶颈所在。找到瓶颈下一步就是进行优化。 方法论 可以从下面三个问题出发来判断性能优化是否有效 如何判断性能优化的有效性？ 性能问题通常不是独立问的，如果同时发生先优化哪一个？ 提升性能的方法并不唯一的，当有多钟选择时，改选哪一种？</summary></entry><entry><title type="html">kubernets理解总结</title><link href="/kubernets/2019/03/28/kubernets-1.html" rel="alternate" type="text/html" title="kubernets理解总结" /><published>2019-03-28T00:00:00+08:00</published><updated>2019-03-28T00:00:00+08:00</updated><id>/kubernets/2019/03/28/kubernets-1</id><content type="html" xml:base="/kubernets/2019/03/28/kubernets-1.html">&lt;p&gt;总体理解kubernets架构以及各个结构中的api使用&lt;/p&gt;

&lt;h2 id=&quot;node&quot;&gt;Node&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;节点：可以使虚拟机，也可以是实体机&lt;/li&gt;
  &lt;li&gt;每个节点上都安装kubernets&lt;/li&gt;
  &lt;li&gt;有主节点和子节点的区分&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;pods&quot;&gt;Pods&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;是组成节点的最小单位，是任意独立的容器,pos都存储在Node中，每个pos有自己的功能&lt;/li&gt;
  &lt;li&gt;获取Pods&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    kubectl get pods
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;查看Pods 描述&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    kubectl describe deployment
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;进入pods中&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    kubectl exec -ti $POD_NAME
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;service&quot;&gt;Service&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;通过service向外暴露pods&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    kubectl expose deployment/kubernetes-bootcamp --type=&quot;NodePort&quot; --port 8080
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;查看service&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    kubectl get services
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;查看service描述&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    kubectl describe services/kubernetes-bootcamp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;根据标签删除services&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    kubectl delete service -l run=kubernetes-bootcamp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;label&quot;&gt;Label&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;每个部署的pods 都会自动创建标签&lt;/li&gt;
  &lt;li&gt;通过标签查询pods&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    kubectl get pods -l kubectl describe deployment
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;重新设置标签&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    kubectl label pod $POD_NAME app=v1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;scale&quot;&gt;Scale&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;自动扩容缩容
    &lt;ul&gt;
      &lt;li&gt;各种状态
        &lt;ol&gt;
          &lt;li&gt;DESIRED 想要的容器数量&lt;/li&gt;
          &lt;li&gt;CURRENT 当前的数量&lt;/li&gt;
          &lt;li&gt;UP-TO-DATE ？？&lt;/li&gt;
          &lt;li&gt;AVAILABLE 有效的&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    kubectl scale deployments/kubernetes-bootcamp --replicas=4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;rolling-update&quot;&gt;Rolling Update&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;滚动更新
    &lt;ul&gt;
      &lt;li&gt;通过镜像更新pods&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=jocatalin/kubernetes-bootcamp:v2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;检查滚动更新状态&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    kubectl rollout status deployments/kubernetes-bootcamp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">总体理解kubernets架构以及各个结构中的api使用</summary></entry><entry><title type="html">Github免费博客空间</title><link href="/blog/2019/03/26/jekyll-blog.html" rel="alternate" type="text/html" title="Github免费博客空间" /><published>2019-03-26T16:39:26+08:00</published><updated>2019-03-26T16:39:26+08:00</updated><id>/blog/2019/03/26/jekyll-blog</id><content type="html" xml:base="/blog/2019/03/26/jekyll-blog.html">&lt;p&gt;本来想自己买服务器，搭建自己的博客，突然google到一种不用服务器也可以做自己博客的方式，利用github pages搭建自己的博客个人实践，完全可行。步骤如下：&lt;/p&gt;

&lt;h3 id=&quot;创建代码库&quot;&gt;创建代码库&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;创建一个自己的代码库blog&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;注意下面两个设置&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/1.png&quot; alt=&quot;设置1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2.png&quot; alt=&quot;设置1&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;安装环境&quot;&gt;安装环境&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;安装ruby(已安装跳过)&lt;/li&gt;
  &lt;li&gt;安装jekyll
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#安装jekyll 
gem install bundler jekyll
#新建jekyll羡慕
jekyll new my_blog
cd my_blog
#开启本地服务
bundle exec jekyll serve
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;我是使用vm虚拟机为了方便本地调试，利用反向代理本地服务
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server {
  listen 80;
  server_name ytiamo.com;
  location /{
      proxy_pass http://127.0.0.1:4000;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;补充知识点可以利用参数-H 来指定主机
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bundle exec jekyll serve -H 192.168.112.20
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;注意：代码库目录和jekyll代码目录是不同目录，最后将代码库目录更新到github&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;博客撰写&quot;&gt;博客撰写&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;从远端拉取自己的代码库
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/xxxxxx/blog.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;构建部署&quot;&gt;构建部署&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;构建代码到你的到blog目录
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jekyll build --destination ../blog/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;推送代码到远端&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">本来想自己买服务器，搭建自己的博客，突然google到一种不用服务器也可以做自己博客的方式，利用github pages搭建自己的博客个人实践，完全可行。步骤如下：</summary></entry><entry><title type="html">linux 高性能学习笔记7</title><link href="/linux/2018/12/20/linux-high-7.html" rel="alternate" type="text/html" title="linux 高性能学习笔记7" /><published>2018-12-20T16:39:26+08:00</published><updated>2018-12-20T16:39:26+08:00</updated><id>/linux/2018/12/20/linux-high-7</id><content type="html" xml:base="/linux/2018/12/20/linux-high-7.html">&lt;p&gt;如何快速查找系统性能瓶颈，分析性能问题&lt;/p&gt;

&lt;h3 id=&quot;概念&quot;&gt;概念&lt;/h3&gt;
&lt;p&gt;如何快速查找系统性能瓶颈&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;cup指标&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;用户态cpu使用量，如果高说明应用处理压力大&lt;/li&gt;
  &lt;li&gt;内核态高，系统处理压力大&lt;/li&gt;
  &lt;li&gt;IO，iowait比较高，说明系统io上有瓶颈&lt;/li&gt;
  &lt;li&gt;中断比较高，说明系统有大量中断&lt;/li&gt;
  &lt;li&gt;出以上情况外还有steal 虚拟机使用情况
    &lt;ol&gt;
      &lt;li&gt;系统平均负载&lt;/li&gt;
      &lt;li&gt;进程切换&lt;/li&gt;
    &lt;/ol&gt;
    &lt;ul&gt;
      &lt;li&gt;无法获取自愿的自愿上下文切换&lt;/li&gt;
      &lt;li&gt;被系统强制调度的上下文切换
        &lt;ol&gt;
          &lt;li&gt;cpu缓存命中率&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/5.png&quot; alt=&quot;设置1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/3.png&quot; alt=&quot;设置1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;性能之间的关联&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/4.png&quot; alt=&quot;设置1&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">如何快速查找系统性能瓶颈，分析性能问题</summary></entry><entry><title type="html">linux 高性能学习笔记5</title><link href="/linux/2018/12/18/linux-high-5.html" rel="alternate" type="text/html" title="linux 高性能学习笔记5" /><published>2018-12-18T16:39:26+08:00</published><updated>2018-12-18T16:39:26+08:00</updated><id>/linux/2018/12/18/linux-high-5</id><content type="html" xml:base="/linux/2018/12/18/linux-high-5.html">&lt;p&gt;对于IO问的分析思路以及命令实践&lt;/p&gt;

&lt;h3 id=&quot;概念&quot;&gt;概念&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;进程状态
    &lt;ul&gt;
      &lt;li&gt;R是running 或 runable 的缩写，表示进程在CPU的就绪队列中，正在运行或者正在等待运行&lt;/li&gt;
      &lt;li&gt;D是Disk sleep的缩写，也就是不可中断状态睡眠，一般表示进程正在跟硬件交互，并且交互过程不允许其他进程或中断打断&lt;/li&gt;
      &lt;li&gt;Z是Zombie的缩写，它表示进程实际上已经结束了，但父进程还没回收它的资源&lt;/li&gt;
      &lt;li&gt;S是interruptible sleep 也就是可中断状态睡眠，它正在等待事件的唤醒转变为R状态&lt;/li&gt;
      &lt;li&gt;l是Idle的缩写，也就是空闲状态，用在不可中断睡眠的内核线程上。D是硬件交互，I是内核空闲，D占用CPU，I不占用&lt;/li&gt;
      &lt;li&gt;丅暂停&lt;/li&gt;
      &lt;li&gt;X DEAD 死亡进程&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;信号：SIGSTOP 暂停 SIGCONT 继续&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;新工具dstat ：可以同时观察 cpu  磁盘  网络以及内存使用情况&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//每秒输出10组数据
dstat 10 1 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;pidstat 参数作用&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//每秒输出20组数据 -d 磁盘操作
pid -d -p 1 20
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;strace 进程追踪:变为了僵尸进程的进程是无法为追踪的&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//追踪进程id
strace -p pid
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;不能追踪只能使用其他工具&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//记录代码段日志 回车进入调用关系
perf record -g
perf report
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;使用pstree查看调用级别&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//查看某个进程占用pid
pstree -aps pid
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;D状态是系统的一种保护机制，为了保护硬件间的交互不被打断。&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">对于IO问的分析思路以及命令实践</summary></entry><entry><title type="html">linux 高性能学习笔记6</title><link href="/linux/2018/12/18/linux-high-6.html" rel="alternate" type="text/html" title="linux 高性能学习笔记6" /><published>2018-12-18T16:39:26+08:00</published><updated>2018-12-18T16:39:26+08:00</updated><id>/linux/2018/12/18/linux-high-6</id><content type="html" xml:base="/linux/2018/12/18/linux-high-6.html">&lt;p&gt;对于中断问的理解与分析&lt;/p&gt;

&lt;h3 id=&quot;概念&quot;&gt;概念&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;中断是一种异步机制，可以提高系统的并发性能&lt;/li&gt;
  &lt;li&gt;中断的理解
    &lt;ul&gt;
      &lt;li&gt;外卖理论（无中断）
        &lt;ul&gt;
          &lt;li&gt;订外卖&lt;/li&gt;
          &lt;li&gt;等外卖：要时不时的去看，错过了外卖就走了&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;外卖理论（有中断）
        &lt;ul&gt;
          &lt;li&gt;订外卖&lt;/li&gt;
          &lt;li&gt;和外卖员协商好，到了给我打电话&lt;/li&gt;
          &lt;li&gt;我可以去干别的了&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;中断丢失
    &lt;ul&gt;
      &lt;li&gt;订了两个外卖，分别有不同的外卖员配送&lt;/li&gt;
      &lt;li&gt;也都协商好了到了打电话&lt;/li&gt;
      &lt;li&gt;当第一个外卖员来了，非要跟我电话1个小时，结果我错过了第二个外卖&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;为了防止中断丢失–软中断
    &lt;ul&gt;
      &lt;li&gt;上半部分快速处理中断&lt;/li&gt;
      &lt;li&gt;下半部分用来延迟，上半部分为完成的部分，通常以内核线程方式运行&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;网卡接受数据过程
    &lt;ul&gt;
      &lt;li&gt;网卡接受到了数据使用硬中断，告诉cpu数据到了&lt;/li&gt;
      &lt;li&gt;cpu立刻中断将数据读取到内存中，最后调用一个软中断&lt;/li&gt;
      &lt;li&gt;触发下半部分中断，在内核状态下进行处理，解析协议逐层发送到应用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;理解
    &lt;ul&gt;
      &lt;li&gt;上半部分直接处理硬件中断&lt;/li&gt;
      &lt;li&gt;下半部分内核触发，就是通常状态下我们说的软中断，特点是延迟处理
        &lt;ul&gt;
          &lt;li&gt;软中断不仅仅是延迟处理&lt;/li&gt;
          &lt;li&gt;还有内核调度&lt;/li&gt;
          &lt;li&gt;RCU 锁（read copy update）&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;如何查看中断情况&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//查看软中断
/pro/softirqs
//查看硬中断
/pro/interrupts
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;软中断类型
    &lt;ul&gt;
      &lt;li&gt;HI&lt;/li&gt;
      &lt;li&gt;TIMER&lt;/li&gt;
      &lt;li&gt;NET_TX：网络发送中断&lt;/li&gt;
      &lt;li&gt;NET_RX：网络接受中断&lt;/li&gt;
      &lt;li&gt;BLOCK&lt;/li&gt;
      &lt;li&gt;IRQ_POLL&lt;/li&gt;
      &lt;li&gt;TASKLET：任务中断，最常用的中断类型和cpu绑定（考虑cpu亲和是不利用这种机制实现）&lt;/li&gt;
      &lt;li&gt;SCHED&lt;/li&gt;
      &lt;li&gt;HRTIMER&lt;/li&gt;
      &lt;li&gt;RCU：read copy update锁&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">对于中断问的理解与分析</summary></entry><entry><title type="html">linux 高性能学习笔记4</title><link href="/linux/2018/12/14/linux-high-4.html" rel="alternate" type="text/html" title="linux 高性能学习笔记4" /><published>2018-12-14T16:39:26+08:00</published><updated>2018-12-14T16:39:26+08:00</updated><id>/linux/2018/12/14/linux-high-4</id><content type="html" xml:base="/linux/2018/12/14/linux-high-4.html">&lt;p&gt;对于cup异常使用，无法找到原因的情况分析思路&lt;/p&gt;

&lt;h3 id=&quot;分析思路&quot;&gt;分析思路&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;使用top 观察cup使用情况，是否能一眼看出使用cup高的进程&lt;/li&gt;
  &lt;li&gt;发现整体非常高，但是每个进程用的却非常少时（多半是有一个瞬时进程不停的启动销毁）&lt;/li&gt;
  &lt;li&gt;使用pidstat 观察进程使用cup情况，也没有发现异常高的程序&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//所有进程使用cpu情况
pidstat 1 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;观察top 的task情况，检查各种状态下的任务情况如果R状态的任务过多时，要考虑是否有大量进程打开
    &lt;ul&gt;
      &lt;li&gt;top  b 命令打开高亮&lt;/li&gt;
      &lt;li&gt;shift+&amp;lt; &amp;gt; 切换到S列观察运行中的程序&lt;/li&gt;
      &lt;li&gt;R 改变排序状态&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;发现异常运行的进程使用pidstat 查看cup使用情况&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//每隔一秒打印指定进程cpu使用情况
pidstat -p pid 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;发现使用当前进程没有cpu使用信息，证明进程已经销毁了（如果怀疑有工具有问题，可以使用其他工具进行确认）&lt;/li&gt;
  &lt;li&gt;同时发现此进程又使用其他的进程id启动了，可能有如下两种原因
    &lt;ul&gt;
      &lt;li&gt;进程不断的崩溃重启&lt;/li&gt;
      &lt;li&gt;进程是短时进程，执行时间很短马上完成&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;使用pstree观察调用链，找到上级调用&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//查看指定进程调用链
pstree | grep stress 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;分析上级调用代码，发现异常部分&lt;/li&gt;
  &lt;li&gt;最后可以用perf top 来记录系统cup 使用情况&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//记录cup 使用情况
perf record -g
//查看报告
perf report
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;额外工具 execsnoop 工具可以查看短时进程情况  使用ftrace技术&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">对于cup异常使用，无法找到原因的情况分析思路</summary></entry><entry><title type="html">linux 高性能学习笔记3</title><link href="/linux/2018/11/30/linux-high-3.html" rel="alternate" type="text/html" title="linux 高性能学习笔记3" /><published>2018-11-30T16:39:26+08:00</published><updated>2018-11-30T16:39:26+08:00</updated><id>/linux/2018/11/30/linux-high-3</id><content type="html" xml:base="/linux/2018/11/30/linux-high-3.html">&lt;p&gt;本节主要是对cpu使用率进行学习&lt;/p&gt;

&lt;h3 id=&quot;相关概念&quot;&gt;相关概念&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;cup使用率
    &lt;ul&gt;
      &lt;li&gt;linux 是多任务操作系统，他会将cup时间切片，通过轮流调度分配给各个任务&lt;/li&gt;
      &lt;li&gt;节拍率，就是将cup时间分为多少分&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;grep 'CONFIG_HZ'= /boot/config-$(uname -r)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;系统分析工具都是计算的间隔时间的使用率&lt;/li&gt;
  &lt;li&gt;性能分析工具perf&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//性能分析
perf top 
//记录性能日志 会生成 perf.data文件
perf record     
//查看日志
perf report
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;相关参数
    &lt;ul&gt;
      &lt;li&gt;overhead 所占比例&lt;/li&gt;
      &lt;li&gt;shared 进程名称&lt;/li&gt;
      &lt;li&gt;object 动态共享对象类型&lt;/li&gt;
      &lt;li&gt;symbol 符号名–函数名&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;cup和nice占用过多说明，用户态进程占用过多的cpu需要着重排查&lt;/li&gt;
  &lt;li&gt;系统cup高，排查系统调用过多排查系统调用问题&lt;/li&gt;
  &lt;li&gt;io等待过高，排查系统存储是否出现问题&lt;/li&gt;
  &lt;li&gt;软中断和硬中断，排查内核中的中断服务是否出现问题&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">本节主要是对cpu使用率进行学习</summary></entry></feed>